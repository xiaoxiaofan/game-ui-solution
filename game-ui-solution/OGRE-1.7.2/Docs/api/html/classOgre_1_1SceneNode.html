<html>
<head>
<title>OGRE: Ogre::SceneNode Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceOgre.html">Ogre</a>::<a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>
  </div>
</div>
<div class="contents">
<h1>Ogre::SceneNode Class Reference<br/>
<small>
[<a class="el" href="group__Scene.html">Scene</a>]</small>
</h1><!-- doxytag: class="Ogre::SceneNode" --><!-- doxytag: inherits="Ogre::Node" -->
<p>Class representing a node in the scene graph.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ogre::SceneNode:</div>
<div class="dynsection">
<div class="center"><img src="classOgre_1_1SceneNode__inherit__graph.gif" border="0" usemap="#Ogre_1_1SceneNode_inherit__map" alt="Inheritance graph"/></div>
<map name="Ogre_1_1SceneNode_inherit__map" id="Ogre_1_1SceneNode_inherit__map">
<area shape="rect" id="node2" href="classOgre_1_1Node.html" title="Class representing a general&#45;purpose node an articulated scene graph." alt="" coords="24,83,112,112"/><area shape="rect" id="node4" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new..." alt="" coords="28,5,108,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classOgre_1_1SceneNode-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef HashMap&lt; <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <br class="typebreak"/>
<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a49043fde03f6003b0cfe1a65f2ff64df">ObjectMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt; <a class="el" href="classOgre_1_1SceneNode.html#a49043fde03f6003b0cfe1a65f2ff64df">ObjectMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a0e2fa88602b6dedc628b66246c1469c9">ObjectIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstMapIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classOgre_1_1SceneNode.html#a49043fde03f6003b0cfe1a65f2ff64df">ObjectMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a87b7fca094d8a66c3a2651916197d052">ConstObjectIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> { <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2">TS_LOCAL</a>, 
<a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">TS_PARENT</a>, 
<a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04">TS_WORLD</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration denoting the spaces which a transform can be relative to. </p>
 <a href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef HashMap&lt; <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1Node.html">Node</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad926e6275c4c0ebe1e28eda5826c2945">ChildNodeMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt; <a class="el" href="classOgre_1_1Node.html#ad926e6275c4c0ebe1e28eda5826c2945">ChildNodeMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a89264ee7507c7f820e57408de1fcc561">ChildNodeIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstMapIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classOgre_1_1Node.html#ad926e6275c4c0ebe1e28eda5826c2945">ChildNodeMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a6e1f37403c498444d14137aa82de1573">ConstChildNodeIterator</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#af12fa7d76755a30ad5ef050008d32220">SceneNode</a> (<a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a> *creator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, only to be called by the creator <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#af12fa7d76755a30ad5ef050008d32220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a952378bf8b65301aec723e020234be6b">SceneNode</a> (<a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a> *creator, const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, only to be called by the creator <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#a952378bf8b65301aec723e020234be6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ac0ed3a17c7150fd03ff625408c745dc9">~SceneNode</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a> (<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an instance of a scene object to this node.  <a href="#a51052c58747a77a6cf7451b700e7eb87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ac440aafa5cb9356e1f4feb17c9fa0cb6">numAttachedObjects</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the number of objects attached to this node.  <a href="#ac440aafa5cb9356e1f4feb17c9fa0cb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#af011d009a2b6d3dfa498721d18a58473">getAttachedObject</a> (unsigned short index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to an attached object.  <a href="#af011d009a2b6d3dfa498721d18a58473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#af890d36d827ac01b125c10c8d2b7c8b3">getAttachedObject</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to an attached object.  <a href="#af890d36d827ac01b125c10c8d2b7c8b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a4d0832b90b91afe9fd4154e12c8481a1">detachObject</a> (unsigned short index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches the indexed object from this scene node.  <a href="#a4d0832b90b91afe9fd4154e12c8481a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#abc4846642c14ab6e3ca1a4f6296b859a">detachObject</a> (<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches an object by pointer.  <a href="#abc4846642c14ab6e3ca1a4f6296b859a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#af52d04c1d2aa341f7e02daeb7355372b">detachObject</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches the named object from this node and returns a pointer to it.  <a href="#af52d04c1d2aa341f7e02daeb7355372b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a064b81e279b10a488ba018d1ac87abb5">detachAllObjects</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches all objects attached to this node.  <a href="#a064b81e279b10a488ba018d1ac87abb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a4e8a3cc40a8b7cac0ea3dd761e51beca">isInSceneGraph</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether this node is in the scene graph, i.e.  <a href="#a4e8a3cc40a8b7cac0ea3dd761e51beca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#af0481ea7c8fb0c5e8a9422dc7ecb60a8">_notifyRootNode</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> that it is the root scene node.  <a href="#af0481ea7c8fb0c5e8a9422dc7ecb60a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a2f49db955276c7740eb98695119927a7">_update</a> (bool updateChildren, bool parentHasChanged)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method to update the <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#a2f49db955276c7740eb98695119927a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a82a14f326bf38f516d8db82a687c987c">_updateBounds</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> to update the world bound info it stores.  <a href="#a82a14f326bf38f516d8db82a687c987c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a188e6ca9a8f9a28f4d2128ca6ebfd2bb">_findVisibleObjects</a> (<a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam, <a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *queue, <a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> *visibleBounds, bool includeChildren=true, bool displayNodes=false, bool onlyShadowCasters=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method which locates any visible objects attached to this node and adds them to the passed in queue.  <a href="#a188e6ca9a8f9a28f4d2128ca6ebfd2bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a14d6924f09bacdad14e6f73b315b9d32">_getWorldAABB</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the axis-aligned bounding box of this node (and hence all subnodes).  <a href="#a14d6924f09bacdad14e6f73b315b9d32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1MapIterator.html">ObjectIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a5f4304385f766666fddfd98c8f59aa48">getAttachedObjectIterator</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an iterator which can be used to efficiently step through the objects attached to this node.  <a href="#a5f4304385f766666fddfd98c8f59aa48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstObjectIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ac171d8535352e644ad4ce667ba23d21b">getAttachedObjectIterator</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an iterator which can be used to efficiently step through the objects attached to this node.  <a href="#ac171d8535352e644ad4ce667ba23d21b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ae17ea5739bf85c988cb21d0df298976f">getCreator</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the creator of this scene node.  <a href="#ae17ea5739bf85c988cb21d0df298976f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#accdf9f05340e6d60d5fc3d2aea6518f2">removeAndDestroyChild</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method removes and destroys the named child and all of its children.  <a href="#accdf9f05340e6d60d5fc3d2aea6518f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a50368a4e1c6464a7de83f5b6c3405483">removeAndDestroyChild</a> (unsigned short index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method removes and destroys the child and all of its children.  <a href="#a50368a4e1c6464a7de83f5b6c3405483"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a26d09fce230659652aac947a61563c2c">removeAndDestroyAllChildren</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and destroys all children of this node.  <a href="#a26d09fce230659652aac947a61563c2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a0f9b0eb8efad4b5dd4130dec5b9fd749">showBoundingBox</a> (bool bShow)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the showing of the node's bounding box.  <a href="#a0f9b0eb8efad4b5dd4130dec5b9fd749"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ac06ea73031258151a7d2c8e78a99120d">hideBoundingBox</a> (bool bHide)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the overriding of the node's bounding box over the SceneManager's bounding box setting.  <a href="#ac06ea73031258151a7d2c8e78a99120d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a7b75761a5809556b3bf9c5d707d68655">_addBoundingBoxToQueue</a> (<a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add the bounding box to the rendering queue.  <a href="#a7b75761a5809556b3bf9c5d707d68655"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#aa073a1b260c539af222cf0006d25801b">getShowBoundingBox</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This allows scene managers to determine if the node's bounding box should be added to the rendering queue.  <a href="#aa073a1b260c539af222cf0006d25801b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;translate=<a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;rotate=<a class="el" href="classOgre_1_1Quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an unnamed new <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as a child of this node.  <a href="#aeaee9cb1cb0c23fab2cc9bab08f51181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a559442664e8b83cb40ca1d2c68c5d01c">createChildSceneNode</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;translate=<a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;rotate=<a class="el" href="classOgre_1_1Quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new named <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as a child of this node.  <a href="#a559442664e8b83cb40ca1d2c68c5d01c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a980c1285648138ce7689d00cd7cd9f65">findLights</a> (<a class="el" href="classOgre_1_1HashedVector.html">LightList</a> &amp;destList, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius, <a class="el" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lightMask=0xFFFFFFFF) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows retrieval of the nearest lights to the centre of this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>.  <a href="#a980c1285648138ce7689d00cd7cd9f65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a47e1d67d84fc3287594fe139097d87a3">setFixedYawAxis</a> (bool useFixed, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;fixedAxis=<a class="el" href="classOgre_1_1Vector3.html#a8d1a1f7af535bcc8d9c78b1732bc1b90">Vector3::UNIT_Y</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice.  <a href="#a47e1d67d84fc3287594fe139097d87a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a0893a9cf482387e50a10d7b2d117efbb">yaw</a> (const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;angle, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_LOCAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around the Y-axis.  <a href="#a0893a9cf482387e50a10d7b2d117efbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a4749203fd450de6af6af90353714b87a">setDirection</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_LOCAL, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;localDirectionVector=<a class="el" href="classOgre_1_1Vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the node's direction vector ie it's local -z.  <a href="#a4749203fd450de6af6af90353714b87a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#adcde26f4821e24a7eebef127251a4bea">setDirection</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;vec, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_LOCAL, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;localDirectionVector=<a class="el" href="classOgre_1_1Vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the node's direction vector ie it's local -z.  <a href="#adcde26f4821e24a7eebef127251a4bea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a4a6e34aab331802bc836668e78a08508">lookAt</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;targetPoint, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;localDirectionVector=<a class="el" href="classOgre_1_1Vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Points the local -Z direction of this node at a point in space.  <a href="#a4a6e34aab331802bc836668e78a08508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a523454b63f484ddbcef8b96b148d4661">setAutoTracking</a> (bool enabled, <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *target=0, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;localDirectionVector=<a class="el" href="classOgre_1_1Vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a>, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;offset=<a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables / disables automatic tracking of another <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>.  <a href="#a523454b63f484ddbcef8b96b148d4661"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a9f25ff62bc7c5f3573872d1937edd35b">getAutoTrackTarget</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the auto tracking target for this node, if any.  <a href="#a9f25ff62bc7c5f3573872d1937edd35b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a3bfbb62bc1e7879e3ed8efab74ff1449">getAutoTrackOffset</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the auto tracking offset for this node, if the node is auto tracking.  <a href="#a3bfbb62bc1e7879e3ed8efab74ff1449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a1c7da5149270d58781185d6c94c90cf3">getAutoTrackLocalDirection</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the auto tracking local direction for this node, if it is auto tracking.  <a href="#a1c7da5149270d58781185d6c94c90cf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ae12f7409930e2c7ae1fb33c39f71d0ea">_autoTrack</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method used by OGRE to update auto-tracking cameras.  <a href="#ae12f7409930e2c7ae1fb33c39f71d0ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a454706e093c4ac83b2bb79a66c3c6bfb">getParentSceneNode</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the parent of this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>.  <a href="#a454706e093c4ac83b2bb79a66c3c6bfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ada725e7b64b51803eaedbe28d7c8195e">setVisible</a> (bool visible, bool cascade=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes all objects attached to this node become visible / invisible.  <a href="#ada725e7b64b51803eaedbe28d7c8195e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ab2f5e0c7aba434f6636329e25593eb33">flipVisibility</a> (bool cascade=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverts the visibility of all objects attached to this node.  <a href="#ab2f5e0c7aba434f6636329e25593eb33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a84902db10180c1460dc0b4e338281280">setDebugDisplayEnabled</a> (bool enabled, bool cascade=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells all objects attached to this node whether to display their debug information or not.  <a href="#a84902db10180c1460dc0b4e338281280"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node_1_1DebugRenderable.html">DebugRenderable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#af2b1f8e20b8d70fc22d358d273e4ea94">getDebugRenderable</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As <a class="el" href="classOgre_1_1Node.html#aab65cbde54e415425ac88fad701b08af" title="Get a debug renderable for rendering the Node.">Node::getDebugRenderable</a>, except scaling is automatically determined.  <a href="#af2b1f8e20b8d70fc22d358d273e4ea94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a3bca2aaf4e01a1447a4aaf4e03a79c18">getName</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the node.  <a href="#a3bca2aaf4e01a1447a4aaf4e03a79c18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a671ade6094f62d64322c222315b9076a">getParent</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets this node's parent (NULL if this is the root).  <a href="#a671ade6094f62d64322c222315b9076a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a5a5840ed5f758d7e3425e0661e4d697b">getOrientation</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a quaternion representing the nodes orientation.  <a href="#a5a5840ed5f758d7e3425e0661e4d697b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aadc391905c7c4ea06b8f5366b6ad10d2">setOrientation</a> (const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the orientation of this node via a quaternion.  <a href="#aadc391905c7c4ea06b8f5366b6ad10d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a412b900632a24e3e8a90c25a5d78d84c">setOrientation</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> w, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the orientation of this node via quaternion parameters.  <a href="#a412b900632a24e3e8a90c25a5d78d84c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a04a385c69650ee62def0cfee923d1ea4">resetOrientation</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the nodes orientation (local axes as world axes, no rotation).  <a href="#a04a385c69650ee62def0cfee923d1ea4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a0064d0828b70b9fd197a7128fbf5b94e">setPosition</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the position of the node relative to it's parent.  <a href="#a0064d0828b70b9fd197a7128fbf5b94e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a37e99410b2de7a2957a4782d8f8ac623">setPosition</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the position of the node relative to it's parent.  <a href="#a37e99410b2de7a2957a4782d8f8ac623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ab39c7a80773f87fca7a2a714760eaca3">getPosition</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the position of the node relative to it's parent.  <a href="#ab39c7a80773f87fca7a2a714760eaca3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad44befdae5ff835dc44db4adcaaee20b">setScale</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the scaling factor applied to this node.  <a href="#ad44befdae5ff835dc44db4adcaaee20b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a5edf4ac8499f761b324fbf4197e77946">setScale</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the scaling factor applied to this node.  <a href="#a5edf4ac8499f761b324fbf4197e77946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a808d57cbb45f340a04342e661d569305">getScale</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the scaling factor of this node.  <a href="#a808d57cbb45f340a04342e661d569305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a8398b5ae334ba06e99c16336fc750f9c">setInheritOrientation</a> (bool inherit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the node whether it should inherit orientation from it's parent node.  <a href="#a8398b5ae334ba06e99c16336fc750f9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aae6a3960b67d52e67e58fac8303b0d0e">getInheritOrientation</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this node is affected by orientation applied to the parent node.  <a href="#aae6a3960b67d52e67e58fac8303b0d0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a646e069c1b418cc820e814209abbf418">setInheritScale</a> (bool inherit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the node whether it should inherit scaling factors from it's parent node.  <a href="#a646e069c1b418cc820e814209abbf418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a55768fe7e128388e62792548511b00a6">getInheritScale</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this node is affected by scaling factors applied to the parent node.  <a href="#a55768fe7e128388e62792548511b00a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad72c1877160fdcde9919787f84d05c85">scale</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the node, combining it's current scale with the passed in scaling factor.  <a href="#ad72c1877160fdcde9919787f84d05c85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a76b6c58ff14ff8c401e773dcb400b7fa">scale</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the node, combining it's current scale with the passed in scaling factor.  <a href="#a76b6c58ff14ff8c401e773dcb400b7fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a67b66f5a377603498e8a45bb5cab61b9">translate</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;d, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_PARENT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the node along the Cartesian axes.  <a href="#a67b66f5a377603498e8a45bb5cab61b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a4b11cb1ea6e2aba1832a56c4ed87f1dd">translate</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_PARENT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the node along the Cartesian axes.  <a href="#a4b11cb1ea6e2aba1832a56c4ed87f1dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ac56415737b8d9a93a3a7f177b22602aa">translate</a> (const <a class="el" href="classOgre_1_1Matrix3.html">Matrix3</a> &amp;axes, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;move, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_PARENT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the node along arbitrary axes.  <a href="#ac56415737b8d9a93a3a7f177b22602aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a4c147221e3963295853affdc2cd06c81">translate</a> (const <a class="el" href="classOgre_1_1Matrix3.html">Matrix3</a> &amp;axes, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_PARENT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the node along arbitrary axes.  <a href="#a4c147221e3963295853affdc2cd06c81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aeb62b05fce457b8509cb95517154425f">roll</a> (const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;angle, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_LOCAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around the Z-axis.  <a href="#aeb62b05fce457b8509cb95517154425f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ac7d3de1c197a805dd692f775fbbeb022">pitch</a> (const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;angle, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_LOCAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around the X-axis.  <a href="#ac7d3de1c197a805dd692f775fbbeb022"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a895ddf042981f7b9e3cf11c694018a5c">rotate</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;axis, const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;angle, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_LOCAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around an arbitrary axis.  <a href="#a895ddf042981f7b9e3cf11c694018a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aef3cc09979efbff06a37974c17fa54ab">rotate</a> (const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;q, <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a> relativeTo=TS_LOCAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around an aritrary axis using a Quarternion.  <a href="#aef3cc09979efbff06a37974c17fa54ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Matrix3.html">Matrix3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ac2c7cc17b873de63998689b0e2ddbd68">getLocalAxes</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent.  <a href="#ac2c7cc17b873de63998689b0e2ddbd68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a8baeb7e192fc802f6bf846d3a69dfc19">createChild</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;translate=<a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;rotate=<a class="el" href="classOgre_1_1Quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an unnamed new <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node.  <a href="#a8baeb7e192fc802f6bf846d3a69dfc19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a5595d0f506945c66795322b1878e16aa">createChild</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;translate=<a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a>, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;rotate=<a class="el" href="classOgre_1_1Quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new named <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node.  <a href="#a5595d0f506945c66795322b1878e16aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad3d47c3e2b3fa5deab934b93666c7f3d">addChild</a> (<a class="el" href="classOgre_1_1Node.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a (precreated) child scene node to this node.  <a href="#ad3d47c3e2b3fa5deab934b93666c7f3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a5d5b4d6045dbf1198e96003ead1b333d">numChildren</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the number of child nodes under this one.  <a href="#a5d5b4d6045dbf1198e96003ead1b333d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a359dd7aae149ada623f2621954a28879">getChild</a> (unsigned short index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a pointer to a child node.  <a href="#a359dd7aae149ada623f2621954a28879"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aff4e184f6376029564986998f1d8cb40">getChild</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a pointer to a named child node.  <a href="#aff4e184f6376029564986998f1d8cb40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1MapIterator.html">ChildNodeIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad8236bbe5857e6e8683b35989a43d774">getChildIterator</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an iterator for efficiently looping through all children of this node.  <a href="#ad8236bbe5857e6e8683b35989a43d774"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstChildNodeIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ace7e53eeb6326e82a0ad8bda139acb94">getChildIterator</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an iterator for efficiently looping through all children of this node.  <a href="#ace7e53eeb6326e82a0ad8bda139acb94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a912d9d3a804edf9faf8a9e32482502b1">removeChild</a> (unsigned short index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops the specified child from this node.  <a href="#a912d9d3a804edf9faf8a9e32482502b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a1dae5b62b42bcb4590aea678c3056f26">removeChild</a> (<a class="el" href="classOgre_1_1Node.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops the specified child from this node.  <a href="#a1dae5b62b42bcb4590aea678c3056f26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a7b1a96d0ca30f5ca56a5dacf27d68f6c">removeChild</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops the named child from this node.  <a href="#a7b1a96d0ca30f5ca56a5dacf27d68f6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a79b3e979879906d5500b961a98d04bc0">removeAllChildren</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all child Nodes attached to this node.  <a href="#a79b3e979879906d5500b961a98d04bc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#abdcc5c2c3462478f33dc91d68b0f8168">_setDerivedPosition</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the final world position of the node directly.  <a href="#abdcc5c2c3462478f33dc91d68b0f8168"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ac2215016d2df55d21b685adde8668832">_setDerivedOrientation</a> (const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the final world orientation of the node directly.  <a href="#ac2215016d2df55d21b685adde8668832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a7cc7b0d580cddfdff16cffd52b7e2bc7">_getDerivedOrientation</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the orientation of the node as derived from all parents.  <a href="#a7cc7b0d580cddfdff16cffd52b7e2bc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aad2fc6f9ec75b32ee1034ee2498aeed8">_getDerivedPosition</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the position of the node as derived from all parents.  <a href="#aad2fc6f9ec75b32ee1034ee2498aeed8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a985d7cf4f1737d401bc93d47b0763c52">_getDerivedScale</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the scaling factor of the node as derived from all parents.  <a href="#a985d7cf4f1737d401bc93d47b0763c52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a58997cd5600d78e6579bba77f2bc8fa7">_getFullTransform</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the full transformation matrix for this node.  <a href="#a58997cd5600d78e6579bba77f2bc8fa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ac958f0d4fad0970aa65bdd0f86de6781">setListener</a> (<a class="el" href="classOgre_1_1Node_1_1Listener.html">Listener</a> *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a listener for this <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#ac958f0d4fad0970aa65bdd0f86de6781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node_1_1Listener.html">Listener</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#abfe7b8c3bd9e9afadaeff3544906ade0">getListener</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current listener for this <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#abfe7b8c3bd9e9afadaeff3544906ade0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a8119af87243123929da530b01dd54fd4">setInitialState</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current transform of this node to be the 'initial state' ie that position / orientation / scale to be used as a basis for delta values used in keyframe animation.  <a href="#a8119af87243123929da530b01dd54fd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a10b19feffaf2d215682ba1aca8d07038">resetToInitialState</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the position / orientation / scale of this node to it's initial state, see setInitialState for more info.  <a href="#a10b19feffaf2d215682ba1aca8d07038"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a1ce1fd23cb72e521701ea577025a975e">getInitialPosition</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the initial position of this node, see setInitialState for more info.  <a href="#a1ce1fd23cb72e521701ea577025a975e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a09a659d354f071feca5eac285f1d55fb">convertWorldToLocalPosition</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;worldPos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the local position, relative to this node, of the given world-space position.  <a href="#a09a659d354f071feca5eac285f1d55fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a57cd15b649fad2def94ba08e6ef230ed">convertLocalToWorldPosition</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;localPos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the world position of a point in the node local space useful for simple transforms that don't require a child node.  <a href="#a57cd15b649fad2def94ba08e6ef230ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ae610a752c80ca9e2ee1938f586a64a2b">convertWorldToLocalOrientation</a> (const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;worldOrientation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the local orientation, relative to this node, of the given world-space orientation.  <a href="#ae610a752c80ca9e2ee1938f586a64a2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aa0d484cf3682a953cdc2f494e080fb99">convertLocalToWorldOrientation</a> (const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;localOrientation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node.  <a href="#aa0d484cf3682a953cdc2f494e080fb99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a83079d6848417455feb56be215439f6b">getInitialOrientation</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the initial orientation of this node, see setInitialState for more info.  <a href="#a83079d6848417455feb56be215439f6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad5604b424c3587333a823d6b71644808">getInitialScale</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the initial position of this node, see setInitialState for more info.  <a href="#ad5604b424c3587333a823d6b71644808"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a5d334dabd3874852ffe3fdd7cbb75bc8">getSquaredViewDepth</a> (const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function, get the squared view depth.  <a href="#a5d334dabd3874852ffe3fdd7cbb75bc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a8671415cc4cf15e45bf716a823678736">needUpdate</a> (bool forceParentUpdate=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To be called in the event of transform changes to this node that require it's recalculation.  <a href="#a8671415cc4cf15e45bf716a823678736"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a58fd5d0595151c204b67738ee789174d">requestUpdate</a> (<a class="el" href="classOgre_1_1Node.html">Node</a> *child, bool forceParentUpdate=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by children to notify their parent that they need an update.  <a href="#a58fd5d0595151c204b67738ee789174d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad7b0459138f43f090fce21e05520b66c">cancelUpdate</a> (<a class="el" href="classOgre_1_1Node.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by children to notify their parent that they no longer need an update.  <a href="#ad7b0459138f43f090fce21e05520b66c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOgre_1_1Node_1_1DebugRenderable.html">DebugRenderable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aab65cbde54e415425ac88fad701b08af">getDebugRenderable</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scaling)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a debug renderable for rendering the <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#aab65cbde54e415425ac88fad701b08af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aa3a25fc37acf61b1b4fd1716c0196ee1">setUserAny</a> (const <a class="el" href="classOgre_1_1Any.html">Any</a> &amp;anything)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Any.html">Any</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a523f3ce4069716f15c97acfa22ec8214">getUserAny</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#af3fcf16e43b07e046816125cbb8dc8f3">getUserObjectBindings</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#af3fcf16e43b07e046816125cbb8dc8f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ab1fd9a93c1ef3d499ba8f332317b9eae">getUserObjectBindings</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#ab1fd9a93c1ef3d499ba8f332317b9eae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a4609e37d3a70cf4318c99e9e1fb8dfd9">queueNeedUpdate</a> (<a class="el" href="classOgre_1_1Node.html">Node</a> *n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue a 'needUpdate' call to a node safely.  <a href="#a4609e37d3a70cf4318c99e9e1fb8dfd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#af990db414b5c4b26b055375401d3b5d1">processQueuedUpdates</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process queued 'needUpdate' calls.  <a href="#af990db414b5c4b26b055375401d3b5d1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1set.html">set</a>&lt; <a class="el" href="classOgre_1_1Node.html">Node</a> * &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aeeff7ca93bca86e92195a69a2cdfe502">ChildUpdateSet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt; <a class="el" href="classOgre_1_1Node.html">Node</a> * &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a747a039791396b55d96c8251186b05cd">QueuedUpdates</a></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a6ed30b55e585e35788ff947146a5d839">updateFromParentImpl</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a696d7c1df8bcabc6a2a3fd2ba3d3ef48">createChildImpl</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#a696d7c1df8bcabc6a2a3fd2ba3d3ef48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a16f45dabc21376b6d91b221cc1c8b906">createChildImpl</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#a16f45dabc21376b6d91b221cc1c8b906"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a9ab0426279d3d191c4c82e21fe59d388">setParent</a> (<a class="el" href="classOgre_1_1Node.html">Node</a> *parent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#a9ab0426279d3d191c4c82e21fe59d388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a5249598f9b893ac14dee5e4bae8622d4">setInSceneGraph</a> (bool inGraph)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for setting whether the node is in the scene graph.  <a href="#a5249598f9b893ac14dee5e4bae8622d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ab163ff6e5b5aab4430490cbb6ca5452f">_updateFromParent</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triggers the node to update it's combined transforms.  <a href="#ab163ff6e5b5aab4430490cbb6ca5452f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1SceneNode.html#a49043fde03f6003b0cfe1a65f2ff64df">ObjectMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a92ed6ce65738128bee3cfcbb9074dab7">mObjectsByName</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1WireBoundingBox.html">WireBoundingBox</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ab63dc19d99002d2634db61fdfb2042bc">mWireBoundingBox</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a Wire Bounding <a class="el" href="structOgre_1_1Box.html" title="Structure used to define a box in a 3-D integer space.">Box</a> for this <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#ab63dc19d99002d2634db61fdfb2042bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a2a23d7a4772313b1d4568b946dfe23a0">mShowBoundingBox</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag that determines if the bounding box of the node should be displayed.  <a href="#a2a23d7a4772313b1d4568b946dfe23a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a6f7d07c6abffa9ab419165696471a874">mHideBoundingBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a3ed43b1903a0255a82ee41571b3ac108">mCreator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> which created this node.  <a href="#a3ed43b1903a0255a82ee41571b3ac108"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#aae5a245a9ef39e8a32f15360b7404d92">mWorldAABB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">World-Axis aligned bounding box, updated only through _update.  <a href="#aae5a245a9ef39e8a32f15360b7404d92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a79fe2c7ff9599191a58902cdae1b3a3f">mYawFixed</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether to yaw around a fixed axis.  <a href="#a79fe2c7ff9599191a58902cdae1b3a3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a37db788390eb6da498e0e4bfeb2400e1">mYawFixedAxis</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fixed axis to yaw around.  <a href="#a37db788390eb6da498e0e4bfeb2400e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#ad5ab7b1d824dc3be02e1f116d0801b40">mAutoTrackTarget</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auto tracking target.  <a href="#ad5ab7b1d824dc3be02e1f116d0801b40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a79a962278ebfd05a0371659f0915650e">mAutoTrackOffset</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tracking offset for fine tuning.  <a href="#a79a962278ebfd05a0371659f0915650e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#a3718047a30a7575e283604ae27bdc31b">mAutoTrackLocalDirection</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local 'normal' direction vector.  <a href="#a3718047a30a7575e283604ae27bdc31b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneNode.html#abde5946531210225faafcf92b7eb4660">mIsInSceneGraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this node a current part of the scene graph?  <a href="#abde5946531210225faafcf92b7eb4660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a24d11a360b70ac6f37e4287bfbc223f7">mParent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to parent node.  <a href="#a24d11a360b70ac6f37e4287bfbc223f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Node.html#ad926e6275c4c0ebe1e28eda5826c2945">ChildNodeMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad508313713b823331eca7a3f6a4fd002">mChildren</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of pointers to direct children; hashmap for efficiency.  <a href="#ad508313713b823331eca7a3f6a4fd002"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Node.html#aeeff7ca93bca86e92195a69a2cdfe502">ChildUpdateSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a54aa00f1ca77a93516bc2d1b08b30648">mChildrenToUpdate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of children which need updating, used if self is not out of date but children are.  <a href="#a54aa00f1ca77a93516bc2d1b08b30648"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ae964b315ed79aef118b71b4c3b6466cd">mNeedParentUpdate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to indicate own transform from parent is out of date.  <a href="#ae964b315ed79aef118b71b4c3b6466cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a4d4eff00d6dbea91264b52046cc367b5">mNeedChildUpdate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating that all children need to be updated.  <a href="#a4d4eff00d6dbea91264b52046cc367b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ab270a19a8d2466230f5906883534d1b0">mParentNotified</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating that parent has been notified about update request.  <a href="#ab270a19a8d2466230f5906883534d1b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a64114e8a49a4db05074790280dc30cf0">mQueuedForUpdate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating that the node has been queued for update.  <a href="#a64114e8a49a4db05074790280dc30cf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a6580e36ab5bbec5d074efe6bfe0dcd79">mName</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Friendly name of this node, can be automatically generated if you don't care.  <a href="#a6580e36ab5bbec5d074efe6bfe0dcd79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a2c40bc581d9ebbbf7e2d056c2bc8ffde">mOrientation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores the orientation of the node relative to it's parent.  <a href="#a2c40bc581d9ebbbf7e2d056c2bc8ffde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a9ef4388bfc132db4a7f6a55f0352166e">mPosition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores the position/translation of the node relative to its parent.  <a href="#a9ef4388bfc132db4a7f6a55f0352166e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a858fbfaad27833ca00f8d0a1adf3093a">mScale</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores the scaling factor applied to this node.  <a href="#a858fbfaad27833ca00f8d0a1adf3093a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ad85766c2f287598bb1059e84ce73e7bb">mInheritOrientation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores whether this node inherits orientation from it's parent.  <a href="#ad85766c2f287598bb1059e84ce73e7bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ab10376524767e0b8a9e86964956f0b40">mInheritScale</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores whether this node inherits scale from it's parent.  <a href="#ab10376524767e0b8a9e86964956f0b40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a7d7d9e45beb547ba72ce33f0274c1167">mDerivedOrientation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached combined orientation.  <a href="#a7d7d9e45beb547ba72ce33f0274c1167"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a7fc19ff96fcb001d6e9981f439bb0eed">mDerivedPosition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached combined position.  <a href="#a7fc19ff96fcb001d6e9981f439bb0eed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a2e5ca471f5154645a596cd230ea94af2">mDerivedScale</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached combined scale.  <a href="#a2e5ca471f5154645a596cd230ea94af2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#aa23946bc6edd30b225a2f04170f04c89">mInitialPosition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The position to use as a base for keyframe animation.  <a href="#aa23946bc6edd30b225a2f04170f04c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a88590f5a049463362c0d2cec07bdca39">mInitialOrientation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The orientation to use as a base for keyframe animation.  <a href="#a88590f5a049463362c0d2cec07bdca39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a3f7a0ccee23accbece0017bec7dcd1ad">mInitialScale</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scale to use as a base for keyframe animation.  <a href="#a3f7a0ccee23accbece0017bec7dcd1ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a88c50934c653fd86447cc81da0998e81">mCachedTransform</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached derived transform as a 4x4 matrix.  <a href="#a88c50934c653fd86447cc81da0998e81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#abeb1d94ee7b8cd7a612a30b510ccee6d">mCachedTransformOutOfDate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Node_1_1Listener.html">Listener</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a4cff3c3bdbe9243a4fd8d928c93365d0">mListener</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> listener - only one allowed (no list) for size &amp; performance reasons.  <a href="#a4cff3c3bdbe9243a4fd8d928c93365d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Node_1_1DebugRenderable.html">DebugRenderable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ac6d7568e730aee21dd64702afa03ba4d">mDebug</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#a231ea555d7cc14a041557df9b63d667c">mUserObjectBindings</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User objects binding.  <a href="#a231ea555d7cc14a041557df9b63d667c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOgre_1_1NameGenerator.html">NameGenerator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ab685c7e9f419db77e0f85331ea3cdca3">msNameGenerator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Incremented count for next name extension.  <a href="#ab685c7e9f419db77e0f85331ea3cdca3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOgre_1_1Node.html#a747a039791396b55d96c8251186b05cd">QueuedUpdates</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Node.html#ab0bc2321f649cd0165a442e7d3a8ad6e">msQueuedUpdates</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class representing a node in the scene graph. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> is a type of <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> which is used to organise objects in a scene. It has the same hierarchical transformation properties of the generic <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> class, but also adds the ability to attach world objects to the node, and stores hierarchical bounding volumes of the nodes in the tree. Child nodes are contained within the bounds of the parent, and so on down the tree, allowing for fast culling. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00057">57</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a89264ee7507c7f820e57408de1fcc561"></a><!-- doxytag: member="Ogre::SceneNode::ChildNodeIterator" ref="a89264ee7507c7f820e57408de1fcc561" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt;<a class="el" href="classOgre_1_1Node.html#ad926e6275c4c0ebe1e28eda5826c2945">ChildNodeMap</a>&gt; <a class="el" href="classOgre_1_1MapIterator.html">Ogre::Node::ChildNodeIterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00077">77</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad926e6275c4c0ebe1e28eda5826c2945"></a><!-- doxytag: member="Ogre::SceneNode::ChildNodeMap" ref="ad926e6275c4c0ebe1e28eda5826c2945" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HashMap&lt;<a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1Node.html">Node</a>*&gt; <a class="el" href="classOgre_1_1Node.html#ad926e6275c4c0ebe1e28eda5826c2945">Ogre::Node::ChildNodeMap</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00076">76</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeeff7ca93bca86e92195a69a2cdfe502"></a><!-- doxytag: member="Ogre::SceneNode::ChildUpdateSet" ref="aeeff7ca93bca86e92195a69a2cdfe502" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1set.html">set</a>&lt;<a class="el" href="classOgre_1_1Node.html">Node</a>*&gt;::type <a class="el" href="classOgre_1_1Node.html#aeeff7ca93bca86e92195a69a2cdfe502">Ogre::Node::ChildUpdateSet</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00129">129</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e1f37403c498444d14137aa82de1573"></a><!-- doxytag: member="Ogre::SceneNode::ConstChildNodeIterator" ref="a6e1f37403c498444d14137aa82de1573" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstMapIterator</a>&lt;<a class="el" href="classOgre_1_1Node.html#ad926e6275c4c0ebe1e28eda5826c2945">ChildNodeMap</a>&gt; <a class="el" href="classOgre_1_1ConstMapIterator.html">Ogre::Node::ConstChildNodeIterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00078">78</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a87b7fca094d8a66c3a2651916197d052"></a><!-- doxytag: member="Ogre::SceneNode::ConstObjectIterator" ref="a87b7fca094d8a66c3a2651916197d052" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstMapIterator</a>&lt;<a class="el" href="classOgre_1_1SceneNode.html#a49043fde03f6003b0cfe1a65f2ff64df">ObjectMap</a>&gt; <a class="el" href="classOgre_1_1ConstMapIterator.html">Ogre::SceneNode::ConstObjectIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00062">62</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e2fa88602b6dedc628b66246c1469c9"></a><!-- doxytag: member="Ogre::SceneNode::ObjectIterator" ref="a0e2fa88602b6dedc628b66246c1469c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt;<a class="el" href="classOgre_1_1SceneNode.html#a49043fde03f6003b0cfe1a65f2ff64df">ObjectMap</a>&gt; <a class="el" href="classOgre_1_1MapIterator.html">Ogre::SceneNode::ObjectIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00061">61</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a49043fde03f6003b0cfe1a65f2ff64df"></a><!-- doxytag: member="Ogre::SceneNode::ObjectMap" ref="a49043fde03f6003b0cfe1a65f2ff64df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HashMap&lt;<a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>*&gt; <a class="el" href="classOgre_1_1SceneNode.html#a49043fde03f6003b0cfe1a65f2ff64df">Ogre::SceneNode::ObjectMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00060">60</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a747a039791396b55d96c8251186b05cd"></a><!-- doxytag: member="Ogre::SceneNode::QueuedUpdates" ref="a747a039791396b55d96c8251186b05cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt;<a class="el" href="classOgre_1_1Node.html">Node</a>*&gt;::type <a class="el" href="classOgre_1_1Node.html#a747a039791396b55d96c8251186b05cd">Ogre::Node::QueuedUpdates</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00229">229</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ac42e2063379286eb673eaffff6ca5e99"></a><!-- doxytag: member="Ogre::SceneNode::TransformSpace" ref="ac42e2063379286eb673eaffff6ca5e99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">Ogre::Node::TransformSpace</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration denoting the spaces which a transform can be relative to. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2"></a><!-- doxytag: member="TS_LOCAL" ref="ac42e2063379286eb673eaffff6ca5e99afcc5f69a4f8962eec29c8b57c1a675a2" args="" -->TS_LOCAL</em>&nbsp;</td><td>
<p>Transform is relative to the local space. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce"></a><!-- doxytag: member="TS_PARENT" ref="ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce" args="" -->TS_PARENT</em>&nbsp;</td><td>
<p>Transform is relative to the space of the parent node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04"></a><!-- doxytag: member="TS_WORLD" ref="ac42e2063379286eb673eaffff6ca5e99ae28ff4f09161c3f5d19c08c5ef210e04" args="" -->TS_WORLD</em>&nbsp;</td><td>
<p>Transform is relative to world space. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00067">67</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af12fa7d76755a30ad5ef050008d32220"></a><!-- doxytag: member="Ogre::SceneNode::SceneNode" ref="af12fa7d76755a30ad5ef050008d32220" args="(SceneManager *creator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::SceneNode::SceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a> *&nbsp;</td>
          <td class="paramname"> <em>creator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, only to be called by the creator <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Creates a node with a generated name. </dd></dl>

</div>
</div>
<a class="anchor" id="a952378bf8b65301aec723e020234be6b"></a><!-- doxytag: member="Ogre::SceneNode::SceneNode" ref="a952378bf8b65301aec723e020234be6b" args="(SceneManager *creator, const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::SceneNode::SceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a> *&nbsp;</td>
          <td class="paramname"> <em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, only to be called by the creator <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Creates a node with a specified name. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0ed3a17c7150fd03ff625408c745dc9"></a><!-- doxytag: member="Ogre::SceneNode::~SceneNode" ref="ac0ed3a17c7150fd03ff625408c745dc9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::SceneNode::~SceneNode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7b75761a5809556b3bf9c5d707d68655"></a><!-- doxytag: member="Ogre::SceneNode::_addBoundingBoxToQueue" ref="a7b75761a5809556b3bf9c5d707d68655" args="(RenderQueue *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::_addBoundingBoxToQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add the bounding box to the rendering queue. </p>

</div>
</div>
<a class="anchor" id="ae12f7409930e2c7ae1fb33c39f71d0ea"></a><!-- doxytag: member="Ogre::SceneNode::_autoTrack" ref="ae12f7409930e2c7ae1fb33c39f71d0ea" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::_autoTrack </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method used by OGRE to update auto-tracking cameras. </p>

</div>
</div>
<a class="anchor" id="a188e6ca9a8f9a28f4d2128ca6ebfd2bb"></a><!-- doxytag: member="Ogre::SceneNode::_findVisibleObjects" ref="a188e6ca9a8f9a28f4d2128ca6ebfd2bb" args="(Camera *cam, RenderQueue *queue, VisibleObjectsBoundsInfo *visibleBounds, bool includeChildren=true, bool displayNodes=false, bool onlyShadowCasters=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::_findVisibleObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>visibleBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>includeChildren</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>displayNodes</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onlyShadowCasters</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method which locates any visible objects attached to this node and adds them to the passed in queue. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Should only be called by a <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementation, and only after the _updat method has been called to ensure transforms and world bounds are up to date. <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementations can choose to let the search cascade automatically, or choose to prevent this and select nodes themselves based on some other criteria. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cam</em>&nbsp;</td><td>The active camera </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>The SceneManager's rendering queue </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visibleBounds</em>&nbsp;</td><td>bounding information created on the fly containing all visible objects by the camera </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>includeChildren</em>&nbsp;</td><td>If true, the call is cascaded down to all child nodes automatically. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>displayNodes</em>&nbsp;</td><td>If true, the nodes themselves are rendered as a set of 3 axes as well as the objects being rendered. For debugging purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cc7b0d580cddfdff16cffd52b7e2bc7"></a><!-- doxytag: member="Ogre::SceneNode::_getDerivedOrientation" ref="a7cc7b0d580cddfdff16cffd52b7e2bc7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&amp; Ogre::Node::_getDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the orientation of the node as derived from all parents. </p>

</div>
</div>
<a class="anchor" id="aad2fc6f9ec75b32ee1034ee2498aeed8"></a><!-- doxytag: member="Ogre::SceneNode::_getDerivedPosition" ref="aad2fc6f9ec75b32ee1034ee2498aeed8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&amp; Ogre::Node::_getDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the position of the node as derived from all parents. </p>

</div>
</div>
<a class="anchor" id="a985d7cf4f1737d401bc93d47b0763c52"></a><!-- doxytag: member="Ogre::SceneNode::_getDerivedScale" ref="a985d7cf4f1737d401bc93d47b0763c52" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&amp; Ogre::Node::_getDerivedScale </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the scaling factor of the node as derived from all parents. </p>

</div>
</div>
<a class="anchor" id="a58997cd5600d78e6579bba77f2bc8fa7"></a><!-- doxytag: member="Ogre::SceneNode::_getFullTransform" ref="a58997cd5600d78e6579bba77f2bc8fa7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a>&amp; Ogre::Node::_getFullTransform </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the full transformation matrix for this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method returns the full transformation matrix for this node, including the effect of any parent node transformations, provided they have been updated using the <a class="el" href="classOgre_1_1Node.html#a5e829eb9715fa8fa1fdc99739d734eac" title="Internal method to update the Node.">Node::_update</a> method. This should only be called by a <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> which knows the derived transforms have been updated before calling this method. Applications using <a class="el" href="namespaceOgre.html">Ogre</a> should just use the relative transforms. </dd></dl>

</div>
</div>
<a class="anchor" id="a14d6924f09bacdad14e6f73b315b9d32"></a><!-- doxytag: member="Ogre::SceneNode::_getWorldAABB" ref="a14d6924f09bacdad14e6f73b315b9d32" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a>&amp; Ogre::SceneNode::_getWorldAABB </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the axis-aligned bounding box of this node (and hence all subnodes). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Recommended only if you are extending a <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>, because the bounding box returned from this method is only up to date after the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> has called _update. </dd></dl>

</div>
</div>
<a class="anchor" id="af0481ea7c8fb0c5e8a9422dc7ecb60a8"></a><!-- doxytag: member="Ogre::SceneNode::_notifyRootNode" ref="af0481ea7c8fb0c5e8a9422dc7ecb60a8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::_notifyRootNode </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> that it is the root scene node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> should call this! </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00169">169</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac2215016d2df55d21b685adde8668832"></a><!-- doxytag: member="Ogre::SceneNode::_setDerivedOrientation" ref="ac2215016d2df55d21b685adde8668832" args="(const Quaternion &amp;q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::_setDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the final world orientation of the node directly. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>It's advisable to use the local setOrientation if possible, this simply does the conversion for you. </dd></dl>

</div>
</div>
<a class="anchor" id="abdcc5c2c3462478f33dc91d68b0f8168"></a><!-- doxytag: member="Ogre::SceneNode::_setDerivedPosition" ref="abdcc5c2c3462478f33dc91d68b0f8168" args="(const Vector3 &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::_setDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the final world position of the node directly. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>It's advisable to use the local setPosition if possible </dd></dl>

</div>
</div>
<a class="anchor" id="a2f49db955276c7740eb98695119927a7"></a><!-- doxytag: member="Ogre::SceneNode::_update" ref="a2f49db955276c7740eb98695119927a7" args="(bool updateChildren, bool parentHasChanged)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::_update </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>updateChildren</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>parentHasChanged</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method to update the <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates this scene node and any relevant children to incorporate transforms etc. Don't call this yourself unless you are writing a <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>updateChildren</em>&nbsp;</td><td>If true, the update cascades down to all children. Specify false if you wish to update children separately, e.g. because of a more selective <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentHasChanged</em>&nbsp;</td><td>This flag indicates that the parent xform has changed, so the child should retrieve the parent's xform and combine it with its own even if it hasn't changed itself. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOgre_1_1Node.html#a5e829eb9715fa8fa1fdc99739d734eac">Ogre::Node</a>.</p>

</div>
</div>
<a class="anchor" id="a82a14f326bf38f516d8db82a687c987c"></a><!-- doxytag: member="Ogre::SceneNode::_updateBounds" ref="a82a14f326bf38f516d8db82a687c987c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::_updateBounds </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> to update the world bound info it stores. </p>

</div>
</div>
<a class="anchor" id="ab163ff6e5b5aab4430490cbb6ca5452f"></a><!-- doxytag: member="Ogre::SceneNode::_updateFromParent" ref="ab163ff6e5b5aab4430490cbb6ca5452f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::_updateFromParent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Triggers the node to update it's combined transforms. </p>
<dl class="user"><dt><b></b></dt><dd>This method is called internally by <a class="el" href="namespaceOgre.html">Ogre</a> to ask the node to update it's complete transformation based on it's parents derived transform. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3d47c3e2b3fa5deab934b93666c7f3d"></a><!-- doxytag: member="Ogre::SceneNode::addChild" ref="ad3d47c3e2b3fa5deab934b93666c7f3d" args="(Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a (precreated) child scene node to this node. </p>
<p>If it is attached to another node, it must be detached first. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>The <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> which is to become a child node of this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51052c58747a77a6cf7451b700e7eb87"></a><!-- doxytag: member="Ogre::SceneNode::attachObject" ref="a51052c58747a77a6cf7451b700e7eb87" args="(MovableObject *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::attachObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an instance of a scene object to this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Scene objects can include <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> objects, <a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> objects, <a class="el" href="classOgre_1_1Light.html" title="Representation of a dynamic light source in the scene.">Light</a> objects, <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> objects etc. Anything that subclasses from <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7b0459138f43f090fce21e05520b66c"></a><!-- doxytag: member="Ogre::SceneNode::cancelUpdate" ref="ad7b0459138f43f090fce21e05520b66c" args="(Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::cancelUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by children to notify their parent that they no longer need an update. </p>

</div>
</div>
<a class="anchor" id="aa0d484cf3682a953cdc2f494e080fb99"></a><!-- doxytag: member="Ogre::SceneNode::convertLocalToWorldOrientation" ref="aa0d484cf3682a953cdc2f494e080fb99" args="(const Quaternion &amp;localOrientation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> Ogre::Node::convertLocalToWorldOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localOrientation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a class="anchor" id="a57cd15b649fad2def94ba08e6ef230ed"></a><!-- doxytag: member="Ogre::SceneNode::convertLocalToWorldPosition" ref="a57cd15b649fad2def94ba08e6ef230ed" args="(const Vector3 &amp;localPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> Ogre::Node::convertLocalToWorldPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localPos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the world position of a point in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a class="anchor" id="ae610a752c80ca9e2ee1938f586a64a2b"></a><!-- doxytag: member="Ogre::SceneNode::convertWorldToLocalOrientation" ref="ae610a752c80ca9e2ee1938f586a64a2b" args="(const Quaternion &amp;worldOrientation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> Ogre::Node::convertWorldToLocalOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>worldOrientation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the local orientation, relative to this node, of the given world-space orientation. </p>

</div>
</div>
<a class="anchor" id="a09a659d354f071feca5eac285f1d55fb"></a><!-- doxytag: member="Ogre::SceneNode::convertWorldToLocalPosition" ref="a09a659d354f071feca5eac285f1d55fb" args="(const Vector3 &amp;worldPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> Ogre::Node::convertWorldToLocalPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>worldPos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the local position, relative to this node, of the given world-space position. </p>

</div>
</div>
<a class="anchor" id="a5595d0f506945c66795322b1878e16aa"></a><!-- doxytag: member="Ogre::SceneNode::createChild" ref="a5595d0f506945c66795322b1878e16aa" args="(const String &amp;name, const Vector3 &amp;translate=Vector3::ZERO, const Quaternion &amp;rotate=Quaternion::IDENTITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::Node::createChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>translate</em> = <code><a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rotate</em> = <code><a class="el" href="classOgre_1_1Quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new named <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>translate</em>&nbsp;</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotate</em>&nbsp;</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8baeb7e192fc802f6bf846d3a69dfc19"></a><!-- doxytag: member="Ogre::SceneNode::createChild" ref="a8baeb7e192fc802f6bf846d3a69dfc19" args="(const Vector3 &amp;translate=Vector3::ZERO, const Quaternion &amp;rotate=Quaternion::IDENTITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::Node::createChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>translate</em> = <code><a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rotate</em> = <code><a class="el" href="classOgre_1_1Quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unnamed new <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> as a child of this node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>translate</em>&nbsp;</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotate</em>&nbsp;</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16f45dabc21376b6d91b221cc1c8b906"></a><!-- doxytag: member="Ogre::SceneNode::createChildImpl" ref="a16f45dabc21376b6d91b221cc1c8b906" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::SceneNode::createChildImpl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

<p>Implements <a class="el" href="classOgre_1_1Node.html#ac034337bcfce2c845be36abb67c9f1f9">Ogre::Node</a>.</p>

</div>
</div>
<a class="anchor" id="a696d7c1df8bcabc6a2a3fd2ba3d3ef48"></a><!-- doxytag: member="Ogre::SceneNode::createChildImpl" ref="a696d7c1df8bcabc6a2a3fd2ba3d3ef48" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::SceneNode::createChildImpl </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

<p>Implements <a class="el" href="classOgre_1_1Node.html#a1a6b43a08eef91e942a6fa5e2064c210">Ogre::Node</a>.</p>

</div>
</div>
<a class="anchor" id="a559442664e8b83cb40ca1d2c68c5d01c"></a><!-- doxytag: member="Ogre::SceneNode::createChildSceneNode" ref="a559442664e8b83cb40ca1d2c68c5d01c" args="(const String &amp;name, const Vector3 &amp;translate=Vector3::ZERO, const Quaternion &amp;rotate=Quaternion::IDENTITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneNode::createChildSceneNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>translate</em> = <code><a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rotate</em> = <code><a class="el" href="classOgre_1_1Quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new named <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as a child of this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>translate</em>&nbsp;</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotate</em>&nbsp;</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeaee9cb1cb0c23fab2cc9bab08f51181"></a><!-- doxytag: member="Ogre::SceneNode::createChildSceneNode" ref="aeaee9cb1cb0c23fab2cc9bab08f51181" args="(const Vector3 &amp;translate=Vector3::ZERO, const Quaternion &amp;rotate=Quaternion::IDENTITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneNode::createChildSceneNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>translate</em> = <code><a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rotate</em> = <code><a class="el" href="classOgre_1_1Quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unnamed new <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as a child of this node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>translate</em>&nbsp;</td><td>Initial translation offset of child relative to parent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotate</em>&nbsp;</td><td>Initial rotation relative to parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a064b81e279b10a488ba018d1ac87abb5"></a><!-- doxytag: member="Ogre::SceneNode::detachAllObjects" ref="a064b81e279b10a488ba018d1ac87abb5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::detachAllObjects </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detaches all objects attached to this node. </p>

</div>
</div>
<a class="anchor" id="af52d04c1d2aa341f7e02daeb7355372b"></a><!-- doxytag: member="Ogre::SceneNode::detachObject" ref="af52d04c1d2aa341f7e02daeb7355372b" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>* Ogre::SceneNode::detachObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detaches the named object from this node and returns a pointer to it. </p>

</div>
</div>
<a class="anchor" id="abc4846642c14ab6e3ca1a4f6296b859a"></a><!-- doxytag: member="Ogre::SceneNode::detachObject" ref="abc4846642c14ab6e3ca1a4f6296b859a" args="(MovableObject *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::detachObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detaches an object by pointer. </p>

</div>
</div>
<a class="anchor" id="a4d0832b90b91afe9fd4154e12c8481a1"></a><!-- doxytag: member="Ogre::SceneNode::detachObject" ref="a4d0832b90b91afe9fd4154e12c8481a1" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>* Ogre::SceneNode::detachObject </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detaches the indexed object from this scene node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Detaches by index, see the alternate version to detach by name. Object indexes may change as other objects are added / removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a980c1285648138ce7689d00cd7cd9f65"></a><!-- doxytag: member="Ogre::SceneNode::findLights" ref="a980c1285648138ce7689d00cd7cd9f65" args="(LightList &amp;destList, Real radius, uint32 lightMask=0xFFFFFFFF) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::findLights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1HashedVector.html">LightList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>lightMask</em> = <code>0xFFFFFFFF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows retrieval of the nearest lights to the centre of this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method allows a list of lights, ordered by proximity to the centre of this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>, to be retrieved. Can be useful when implementing <a class="el" href="classOgre_1_1MovableObject.html#a2d4c926ce07f3a1cb0e59d9d60aac76b" title="Gets a list of lights, ordered relative to how close they are to this movable object...">MovableObject::queryLights</a> and <a class="el" href="classOgre_1_1Renderable.html#a91a5cc5e517b7c79fa510b9fdcc98691" title="Gets a list of lights, ordered relative to how close they are to this renderable...">Renderable::getLights</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that only lights could be affecting the frustum will take into account, which cached in scene manager. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#a62876dcdf7cb0f7923de88e62cf077ac" title="Get the list of lights which could be affecting the frustum.">SceneManager::_getLightsAffectingFrustum</a> </dd>
<dd>
<a class="el" href="classOgre_1_1SceneManager.html#a165307402bd2bfca5b1f57e08220a739" title="Populate a light list with an ordered set of the lights which are closest to the...">SceneManager::_populateLightList</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destList</em>&nbsp;</td><td>List to be populated with ordered set of lights; will be cleared by this method before population. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>Parameter to specify lights intersecting a given radius of this SceneNode's centre. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lightMask</em>&nbsp;</td><td>The mask with which to include / exclude lights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2f5e0c7aba434f6636329e25593eb33"></a><!-- doxytag: member="Ogre::SceneNode::flipVisibility" ref="ab2f5e0c7aba434f6636329e25593eb33" args="(bool cascade=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::flipVisibility </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>cascade</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts the visibility of all objects attached to this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a shortcut to calling setVisible(!isVisible()) on the objects attached to this node, and optionally to all objects attached to child nodes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cascade</em>&nbsp;</td><td>If true, this setting cascades into child nodes too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af890d36d827ac01b125c10c8d2b7c8b3"></a><!-- doxytag: member="Ogre::SceneNode::getAttachedObject" ref="af890d36d827ac01b125c10c8d2b7c8b3" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>* Ogre::SceneNode::getAttachedObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a pointer to an attached object. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Retrieves by object name, see alternate version to retrieve by index. </dd></dl>

</div>
</div>
<a class="anchor" id="af011d009a2b6d3dfa498721d18a58473"></a><!-- doxytag: member="Ogre::SceneNode::getAttachedObject" ref="af011d009a2b6d3dfa498721d18a58473" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>* Ogre::SceneNode::getAttachedObject </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a pointer to an attached object. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Retrieves by index, see alternate version to retrieve by name. The index of an object may change as other objects are added / removed. </dd></dl>

</div>
</div>
<a class="anchor" id="ac171d8535352e644ad4ce667ba23d21b"></a><!-- doxytag: member="Ogre::SceneNode::getAttachedObjectIterator" ref="ac171d8535352e644ad4ce667ba23d21b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstObjectIterator</a> Ogre::SceneNode::getAttachedObjectIterator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an iterator which can be used to efficiently step through the objects attached to this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a much faster way to go through <b>all</b> the objects attached to the node than using getAttachedObject. But the iterator returned is only valid until a change is made to the collection (ie an addition or removal) so treat the returned iterator as transient, and don't add / remove items as you go through the iterator, save changes until the end, or retrieve a new iterator after making the change. Making changes to the object returned through the iterator is OK though. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f4304385f766666fddfd98c8f59aa48"></a><!-- doxytag: member="Ogre::SceneNode::getAttachedObjectIterator" ref="a5f4304385f766666fddfd98c8f59aa48" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MapIterator.html">ObjectIterator</a> Ogre::SceneNode::getAttachedObjectIterator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an iterator which can be used to efficiently step through the objects attached to this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a much faster way to go through <b>all</b> the objects attached to the node than using getAttachedObject. But the iterator returned is only valid until a change is made to the collection (ie an addition or removal) so treat the returned iterator as transient, and don't add / remove items as you go through the iterator, save changes until the end, or retrieve a new iterator after making the change. Making changes to the object returned through the iterator is OK though. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c7da5149270d58781185d6c94c90cf3"></a><!-- doxytag: member="Ogre::SceneNode::getAutoTrackLocalDirection" ref="a1c7da5149270d58781185d6c94c90cf3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&amp; Ogre::SceneNode::getAutoTrackLocalDirection </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the auto tracking local direction for this node, if it is auto tracking. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00425">425</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3bfbb62bc1e7879e3ed8efab74ff1449"></a><!-- doxytag: member="Ogre::SceneNode::getAutoTrackOffset" ref="a3bfbb62bc1e7879e3ed8efab74ff1449" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&amp; Ogre::SceneNode::getAutoTrackOffset </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the auto tracking offset for this node, if the node is auto tracking. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00423">423</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9f25ff62bc7c5f3573872d1937edd35b"></a><!-- doxytag: member="Ogre::SceneNode::getAutoTrackTarget" ref="a9f25ff62bc7c5f3573872d1937edd35b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneNode::getAutoTrackTarget </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the auto tracking target for this node, if any. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00421">421</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff4e184f6376029564986998f1d8cb40"></a><!-- doxytag: member="Ogre::SceneNode::getChild" ref="aff4e184f6376029564986998f1d8cb40" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a pointer to a named child node. </p>

</div>
</div>
<a class="anchor" id="a359dd7aae149ada623f2621954a28879"></a><!-- doxytag: member="Ogre::SceneNode::getChild" ref="a359dd7aae149ada623f2621954a28879" args="(unsigned short index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a pointer to a child node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>There is an alternate getChild method which returns a named child. </dd></dl>

</div>
</div>
<a class="anchor" id="ace7e53eeb6326e82a0ad8bda139acb94"></a><!-- doxytag: member="Ogre::SceneNode::getChildIterator" ref="ace7e53eeb6326e82a0ad8bda139acb94" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstChildNodeIterator</a> Ogre::Node::getChildIterator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an iterator for efficiently looping through all children of this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Using this is faster than repeatedly calling getChild if you want to go through all (or most of) the children of this node. Note that the returned iterator is only valid whilst no children are added or removed from this node. Thus you should not store this returned iterator for later use, nor should you add / remove children whilst iterating through it; store up changes for later. Note that calling methods on returned items in the iterator IS allowed and does not invalidate the iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8236bbe5857e6e8683b35989a43d774"></a><!-- doxytag: member="Ogre::SceneNode::getChildIterator" ref="ad8236bbe5857e6e8683b35989a43d774" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MapIterator.html">ChildNodeIterator</a> Ogre::Node::getChildIterator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an iterator for efficiently looping through all children of this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Using this is faster than repeatedly calling getChild if you want to go through all (or most of) the children of this node. Note that the returned iterator is only valid whilst no children are added or removed from this node. Thus you should not store this returned iterator for later use, nor should you add / remove children whilst iterating through it; store up changes for later. Note that calling methods on returned items in the iterator IS allowed and does not invalidate the iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ae17ea5739bf85c988cb21d0df298976f"></a><!-- doxytag: member="Ogre::SceneNode::getCreator" ref="ae17ea5739bf85c988cb21d0df298976f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a>* Ogre::SceneNode::getCreator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the creator of this scene node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method returns the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> which created this node. This can be useful for destroying this node. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00247">247</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab65cbde54e415425ac88fad701b08af"></a><!-- doxytag: member="Ogre::SceneNode::getDebugRenderable" ref="aab65cbde54e415425ac88fad701b08af" args="(Real scaling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node_1_1DebugRenderable.html">DebugRenderable</a>* Ogre::Node::getDebugRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>scaling</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a debug renderable for rendering the <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

</div>
</div>
<a class="anchor" id="af2b1f8e20b8d70fc22d358d273e4ea94"></a><!-- doxytag: member="Ogre::SceneNode::getDebugRenderable" ref="af2b1f8e20b8d70fc22d358d273e4ea94" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node_1_1DebugRenderable.html">DebugRenderable</a>* Ogre::SceneNode::getDebugRenderable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As <a class="el" href="classOgre_1_1Node.html#aab65cbde54e415425ac88fad701b08af" title="Get a debug renderable for rendering the Node.">Node::getDebugRenderable</a>, except scaling is automatically determined. </p>

</div>
</div>
<a class="anchor" id="aae6a3960b67d52e67e58fac8303b0d0e"></a><!-- doxytag: member="Ogre::SceneNode::getInheritOrientation" ref="aae6a3960b67d52e67e58fac8303b0d0e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::Node::getInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node is affected by orientation applied to the parent node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd>
<dd>
See setInheritOrientation for more info. </dd></dl>

</div>
</div>
<a class="anchor" id="a55768fe7e128388e62792548511b00a6"></a><!-- doxytag: member="Ogre::SceneNode::getInheritScale" ref="a55768fe7e128388e62792548511b00a6" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::Node::getInheritScale </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node is affected by scaling factors applied to the parent node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>See setInheritScale for more info. </dd></dl>

</div>
</div>
<a class="anchor" id="a83079d6848417455feb56be215439f6b"></a><!-- doxytag: member="Ogre::SceneNode::getInitialOrientation" ref="a83079d6848417455feb56be215439f6b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&amp; Ogre::Node::getInitialOrientation </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the initial orientation of this node, see setInitialState for more info. </p>

</div>
</div>
<a class="anchor" id="a1ce1fd23cb72e521701ea577025a975e"></a><!-- doxytag: member="Ogre::SceneNode::getInitialPosition" ref="a1ce1fd23cb72e521701ea577025a975e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&amp; Ogre::Node::getInitialPosition </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the initial position of this node, see setInitialState for more info. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Also resets the cumulative animation weight used for blending. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5604b424c3587333a823d6b71644808"></a><!-- doxytag: member="Ogre::SceneNode::getInitialScale" ref="ad5604b424c3587333a823d6b71644808" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&amp; Ogre::Node::getInitialScale </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the initial position of this node, see setInitialState for more info. </p>

</div>
</div>
<a class="anchor" id="abfe7b8c3bd9e9afadaeff3544906ade0"></a><!-- doxytag: member="Ogre::SceneNode::getListener" ref="abfe7b8c3bd9e9afadaeff3544906ade0" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node_1_1Listener.html">Listener</a>* Ogre::Node::getListener </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current listener for this <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00664">664</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac2c7cc17b873de63998689b0e2ddbd68"></a><!-- doxytag: member="Ogre::SceneNode::getLocalAxes" ref="ac2c7cc17b873de63998689b0e2ddbd68" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Matrix3.html">Matrix3</a> Ogre::Node::getLocalAxes </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="a3bca2aaf4e01a1447a4aaf4e03a79c18"></a><!-- doxytag: member="Ogre::SceneNode::getName" ref="a3bca2aaf4e01a1447a4aaf4e03a79c18" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Node::getName </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of the node. </p>

</div>
</div>
<a class="anchor" id="a5a5840ed5f758d7e3425e0661e4d697b"></a><!-- doxytag: member="Ogre::SceneNode::getOrientation" ref="a5a5840ed5f758d7e3425e0661e4d697b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&amp; Ogre::Node::getOrientation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a quaternion representing the nodes orientation. </p>

</div>
</div>
<a class="anchor" id="a671ade6094f62d64322c222315b9076a"></a><!-- doxytag: member="Ogre::SceneNode::getParent" ref="a671ade6094f62d64322c222315b9076a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::Node::getParent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets this node's parent (NULL if this is the root). </p>

</div>
</div>
<a class="anchor" id="a454706e093c4ac83b2bb79a66c3c6bfb"></a><!-- doxytag: member="Ogre::SceneNode::getParentSceneNode" ref="a454706e093c4ac83b2bb79a66c3c6bfb" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneNode::getParentSceneNode </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the parent of this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. </p>

</div>
</div>
<a class="anchor" id="ab39c7a80773f87fca7a2a714760eaca3"></a><!-- doxytag: member="Ogre::SceneNode::getPosition" ref="ab39c7a80773f87fca7a2a714760eaca3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&amp; Ogre::Node::getPosition </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the position of the node relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="a808d57cbb45f340a04342e661d569305"></a><!-- doxytag: member="Ogre::SceneNode::getScale" ref="a808d57cbb45f340a04342e661d569305" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&amp; Ogre::Node::getScale </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the scaling factor of this node. </p>

</div>
</div>
<a class="anchor" id="aa073a1b260c539af222cf0006d25801b"></a><!-- doxytag: member="Ogre::SceneNode::getShowBoundingBox" ref="aa073a1b260c539af222cf0006d25801b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneNode::getShowBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This allows scene managers to determine if the node's bounding box should be added to the rendering queue. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Scene Managers that implement their own _findVisibleObjects will have to check this flag and then use _addBoundingBoxToQueue to add the bounding box wireframe. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d334dabd3874852ffe3fdd7cbb75bc8"></a><!-- doxytag: member="Ogre::SceneNode::getSquaredViewDepth" ref="a5d334dabd3874852ffe3fdd7cbb75bc8" args="(const Camera *cam) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Node::getSquaredViewDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function, get the squared view depth. </p>

</div>
</div>
<a class="anchor" id="a523f3ce4069716f15c97acfa22ec8214"></a><!-- doxytag: member="Ogre::SceneNode::getUserAny" ref="a523f3ce4069716f15c97acfa22ec8214" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Any.html">Any</a>&amp; Ogre::Node::getUserAny </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>use <a class="el" href="classOgre_1_1UserObjectBindings.html#a9c4b12b7ceeddd3a6f28dae1ac8d09a2" title="Retrieves the custom key less user object associated with this class.">UserObjectBindings::getUserAny</a> via <a class="el" href="classOgre_1_1Node.html#af3fcf16e43b07e046816125cbb8dc8f3" title="Return an instance of user objects binding associated with this class.">getUserObjectBindings()</a> instead. Retrieves the custom user value associated with this object. </dd></dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00754">754</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1fd9a93c1ef3d499ba8f332317b9eae"></a><!-- doxytag: member="Ogre::SceneNode::getUserObjectBindings" ref="ab1fd9a93c1ef3d499ba8f332317b9eae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a>&amp; Ogre::Node::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1UserObjectBindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a>. </dd></dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00766">766</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3fcf16e43b07e046816125cbb8dc8f3"></a><!-- doxytag: member="Ogre::SceneNode::getUserObjectBindings" ref="af3fcf16e43b07e046816125cbb8dc8f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a>&amp; Ogre::Node::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1UserObjectBindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a>. </dd></dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00760">760</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac06ea73031258151a7d2c8e78a99120d"></a><!-- doxytag: member="Ogre::SceneNode::hideBoundingBox" ref="ac06ea73031258151a7d2c8e78a99120d" args="(bool bHide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::hideBoundingBox </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bHide</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the overriding of the node's bounding box over the SceneManager's bounding box setting. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Use this to override the bounding box setting of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e8a3cc40a8b7cac0ea3dd761e51beca"></a><!-- doxytag: member="Ogre::SceneNode::isInSceneGraph" ref="a4e8a3cc40a8b7cac0ea3dd761e51beca" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneNode::isInSceneGraph </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether this node is in the scene graph, i.e. </p>
<p>whether it's ultimate ancestor is the root scene node. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00163">163</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4a6e34aab331802bc836668e78a08508"></a><!-- doxytag: member="Ogre::SceneNode::lookAt" ref="a4a6e34aab331802bc836668e78a08508" args="(const Vector3 &amp;targetPoint, TransformSpace relativeTo, const Vector3 &amp;localDirectionVector=Vector3::NEGATIVE_UNIT_Z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::lookAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>targetPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localDirectionVector</em> = <code><a class="el" href="classOgre_1_1Vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Points the local -Z direction of this node at a point in space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>targetPoint</em>&nbsp;</td><td>A vector specifying the look at point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space in which the point resides </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>localDirectionVector</em>&nbsp;</td><td>The vector which normally describes the natural direction of the node, usually -Z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8671415cc4cf15e45bf716a823678736"></a><!-- doxytag: member="Ogre::SceneNode::needUpdate" ref="a8671415cc4cf15e45bf716a823678736" args="(bool forceParentUpdate=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::needUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forceParentUpdate</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To be called in the event of transform changes to this node that require it's recalculation. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>forceParentUpdate</em>&nbsp;</td><td>Even if the node thinks it has already told it's parent, tell it anyway </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOgre_1_1Bone.html#a5b32f720032133ebc0706669b20ee528">Ogre::Bone</a>, and <a class="el" href="classOgre_1_1TagPoint.html#aacb9004b79fb9fceac07ec7963da944e">Ogre::TagPoint</a>.</p>

</div>
</div>
<a class="anchor" id="ac440aafa5cb9356e1f4feb17c9fa0cb6"></a><!-- doxytag: member="Ogre::SceneNode::numAttachedObjects" ref="ac440aafa5cb9356e1f4feb17c9fa0cb6" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned short Ogre::SceneNode::numAttachedObjects </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reports the number of objects attached to this node. </p>

</div>
</div>
<a class="anchor" id="a5d5b4d6045dbf1198e96003ead1b333d"></a><!-- doxytag: member="Ogre::SceneNode::numChildren" ref="a5d5b4d6045dbf1198e96003ead1b333d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned short Ogre::Node::numChildren </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reports the number of child nodes under this one. </p>

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a><!-- doxytag: member="Ogre::SceneNode::operator delete" ref="acb46d4b0a597156d9ba5abc39d127792" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00107">107</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a><!-- doxytag: member="Ogre::SceneNode::operator delete" ref="a1c727e879a260c37b00ce5505fe8e144" args="(void *ptr, void *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00101">101</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a><!-- doxytag: member="Ogre::SceneNode::operator delete" ref="a8357fe4fb4849772b94baa4bf47c7ded" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00095">95</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a><!-- doxytag: member="Ogre::SceneNode::operator delete[]" ref="a595ea4c05da8aa987d3800e65d23355d" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00118">118</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a><!-- doxytag: member="Ogre::SceneNode::operator delete[]" ref="a93e6a86dde5483c053ca0f2a85bbfd6c" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00112">112</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a><!-- doxytag: member="Ogre::SceneNode::operator new" ref="ab78a921e54419be677839cdf15d1f0b8" args="(size_t sz, void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>placement operator new </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00078">78</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a><!-- doxytag: member="Ogre::SceneNode::operator new" ref="ac4bdf968b7b9af8a5239a27da73d5711" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00072">72</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a><!-- doxytag: member="Ogre::SceneNode::operator new" ref="a421b197ca3a38da17e2eb1531a645fa2" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00067">67</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a><!-- doxytag: member="Ogre::SceneNode::operator new[]" ref="afa2943846ba6a2b5824a12857139cf5e" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00090">90</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a><!-- doxytag: member="Ogre::SceneNode::operator new[]" ref="a4be37baef81876985aa1071ad5acc6dd" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>array operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00085">85</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac7d3de1c197a805dd692f775fbbeb022"></a><!-- doxytag: member="Ogre::SceneNode::pitch" ref="ac7d3de1c197a805dd692f775fbbeb022" args="(const Radian &amp;angle, TransformSpace relativeTo=TS_LOCAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::pitch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_LOCAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around the X-axis. </p>

</div>
</div>
<a class="anchor" id="af990db414b5c4b26b055375401d3b5d1"></a><!-- doxytag: member="Ogre::SceneNode::processQueuedUpdates" ref="af990db414b5c4b26b055375401d3b5d1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Node::processQueuedUpdates </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process queued 'needUpdate' calls. </p>

</div>
</div>
<a class="anchor" id="a4609e37d3a70cf4318c99e9e1fb8dfd9"></a><!-- doxytag: member="Ogre::SceneNode::queueNeedUpdate" ref="a4609e37d3a70cf4318c99e9e1fb8dfd9" args="(Node *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Node::queueNeedUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue a 'needUpdate' call to a node safely. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>You can't call <a class="el" href="classOgre_1_1Node.html#a8671415cc4cf15e45bf716a823678736" title="To be called in the event of transform changes to this node that require it&#39;s...">needUpdate()</a> during the scene graph update, e.g. in response to a <a class="el" href="classOgre_1_1Node_1_1Listener.html" title="Listener which gets called back on Node events.">Node::Listener</a> hook, because the graph is already being updated, and update flag changes cannot be made reliably in that context. Call this method if you need to queue a needUpdate call in this case. </dd></dl>

</div>
</div>
<a class="anchor" id="a79b3e979879906d5500b961a98d04bc0"></a><!-- doxytag: member="Ogre::SceneNode::removeAllChildren" ref="a79b3e979879906d5500b961a98d04bc0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all child Nodes attached to this node. </p>
<p>Does not delete the nodes, just detaches them from this parent, potentially to be reattached elsewhere. </p>

</div>
</div>
<a class="anchor" id="a26d09fce230659652aac947a61563c2c"></a><!-- doxytag: member="Ogre::SceneNode::removeAndDestroyAllChildren" ref="a26d09fce230659652aac947a61563c2c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::removeAndDestroyAllChildren </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes and destroys all children of this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Use this to destroy all child nodes of this node and remove them from the scene graph. Note that all objects attached to this node will be detached but will not be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a50368a4e1c6464a7de83f5b6c3405483"></a><!-- doxytag: member="Ogre::SceneNode::removeAndDestroyChild" ref="a50368a4e1c6464a7de83f5b6c3405483" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::removeAndDestroyChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method removes and destroys the child and all of its children. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Unlike removeChild, which removes a single named child from this node but does not destroy it, this method destroys the child and all of it's children. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Use this if you wish to recursively destroy a node as well as detaching it from it's parent. Note that any objects attached to the nodes will be detached but will not themselves be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="accdf9f05340e6d60d5fc3d2aea6518f2"></a><!-- doxytag: member="Ogre::SceneNode::removeAndDestroyChild" ref="accdf9f05340e6d60d5fc3d2aea6518f2" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::removeAndDestroyChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method removes and destroys the named child and all of its children. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Unlike removeChild, which removes a single named child from this node but does not destroy it, this method destroys the child and all of it's children. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Use this if you wish to recursively destroy a node as well as detaching it from it's parent. Note that any objects attached to the nodes will be detached but will not themselves be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b1a96d0ca30f5ca56a5dacf27d68f6c"></a><!-- doxytag: member="Ogre::SceneNode::removeChild" ref="a7b1a96d0ca30f5ca56a5dacf27d68f6c" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drops the named child from this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dae5b62b42bcb4590aea678c3056f26"></a><!-- doxytag: member="Ogre::SceneNode::removeChild" ref="a1dae5b62b42bcb4590aea678c3056f26" args="(Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drops the specified child from this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. There is also an alternate version which drops a named child from this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a912d9d3a804edf9faf8a9e32482502b1"></a><!-- doxytag: member="Ogre::SceneNode::removeChild" ref="a912d9d3a804edf9faf8a9e32482502b1" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Node.html">Node</a>* Ogre::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drops the specified child from this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. There is also an alternate version which drops a named child from this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a58fd5d0595151c204b67738ee789174d"></a><!-- doxytag: member="Ogre::SceneNode::requestUpdate" ref="a58fd5d0595151c204b67738ee789174d" args="(Node *child, bool forceParentUpdate=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::requestUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forceParentUpdate</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by children to notify their parent that they need an update. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>forceParentUpdate</em>&nbsp;</td><td>Even if the node thinks it has already told it's parent, tell it anyway </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04a385c69650ee62def0cfee923d1ea4"></a><!-- doxytag: member="Ogre::SceneNode::resetOrientation" ref="a04a385c69650ee62def0cfee923d1ea4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::resetOrientation </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the nodes orientation (local axes as world axes, no rotation). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a10b19feffaf2d215682ba1aca8d07038"></a><!-- doxytag: member="Ogre::SceneNode::resetToInitialState" ref="a10b19feffaf2d215682ba1aca8d07038" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::resetToInitialState </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the position / orientation / scale of this node to it's initial state, see setInitialState for more info. </p>

</div>
</div>
<a class="anchor" id="aeb62b05fce457b8509cb95517154425f"></a><!-- doxytag: member="Ogre::SceneNode::roll" ref="aeb62b05fce457b8509cb95517154425f" args="(const Radian &amp;angle, TransformSpace relativeTo=TS_LOCAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::roll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_LOCAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around the Z-axis. </p>

</div>
</div>
<a class="anchor" id="aef3cc09979efbff06a37974c17fa54ab"></a><!-- doxytag: member="Ogre::SceneNode::rotate" ref="aef3cc09979efbff06a37974c17fa54ab" args="(const Quaternion &amp;q, TransformSpace relativeTo=TS_LOCAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_LOCAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around an aritrary axis using a Quarternion. </p>

</div>
</div>
<a class="anchor" id="a895ddf042981f7b9e3cf11c694018a5c"></a><!-- doxytag: member="Ogre::SceneNode::rotate" ref="a895ddf042981f7b9e3cf11c694018a5c" args="(const Vector3 &amp;axis, const Radian &amp;angle, TransformSpace relativeTo=TS_LOCAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_LOCAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around an arbitrary axis. </p>

</div>
</div>
<a class="anchor" id="a76b6c58ff14ff8c401e773dcb400b7fa"></a><!-- doxytag: member="Ogre::SceneNode::scale" ref="a76b6c58ff14ff8c401e773dcb400b7fa" args="(Real x, Real y, Real z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the node, combining it's current scale with the passed in scaling factor. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if the existing scale was 1. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="ad72c1877160fdcde9919787f84d05c85"></a><!-- doxytag: member="Ogre::SceneNode::scale" ref="ad72c1877160fdcde9919787f84d05c85" args="(const Vector3 &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the node, combining it's current scale with the passed in scaling factor. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if the existing scale was 1. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a523454b63f484ddbcef8b96b148d4661"></a><!-- doxytag: member="Ogre::SceneNode::setAutoTracking" ref="a523454b63f484ddbcef8b96b148d4661" args="(bool enabled, SceneNode *target=0, const Vector3 &amp;localDirectionVector=Vector3::NEGATIVE_UNIT_Z, const Vector3 &amp;offset=Vector3::ZERO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::setAutoTracking </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localDirectionVector</em> = <code><a class="el" href="classOgre_1_1Vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>offset</em> = <code><a class="el" href="classOgre_1_1Vector3.html#a5da94afc089ec07612b4a2615bb6b86f">Vector3::ZERO</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables / disables automatic tracking of another <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If you enable auto-tracking, this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> will automatically rotate to point it's -Z at the target <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> every frame, no matter how it or the other <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> move. Note that by default the -Z points at the origin of the target <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>, if you want to tweak this, provide a vector in the 'offset' parameter and the target point will be adjusted. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>If true, tracking will be enabled and the next parameter cannot be null. If false tracking will be disabled and the current orientation will be maintained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Pointer to the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> to track. Make sure you don't delete this <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> before turning off tracking (e.g. <a class="el" href="classOgre_1_1SceneManager.html#aa5b2047b5740b691b0e636d57f2dba7e" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets...">SceneManager::clearScene</a> will delete it so be careful of this). Can be null if and only if the enabled param is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>localDirectionVector</em>&nbsp;</td><td>The local vector considered to be the usual 'direction' of the node; normally the local -Z but can be another direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>If supplied, this is the target point in local space of the target node instead of the origin of the target node. Good for fine tuning the look at point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84902db10180c1460dc0b4e338281280"></a><!-- doxytag: member="Ogre::SceneNode::setDebugDisplayEnabled" ref="a84902db10180c1460dc0b4e338281280" args="(bool enabled, bool cascade=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::setDebugDisplayEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>cascade</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells all objects attached to this node whether to display their debug information or not. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a shortcut to calling <a class="el" href="classOgre_1_1SceneNode.html#a84902db10180c1460dc0b4e338281280" title="Tells all objects attached to this node whether to display their debug information...">setDebugDisplayEnabled()</a> on the objects attached to this node, and optionally to all objects attached to child nodes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>Whether the objects are to display debug info or not </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cascade</em>&nbsp;</td><td>If true, this setting cascades into child nodes too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcde26f4821e24a7eebef127251a4bea"></a><!-- doxytag: member="Ogre::SceneNode::setDirection" ref="adcde26f4821e24a7eebef127251a4bea" args="(const Vector3 &amp;vec, TransformSpace relativeTo=TS_LOCAL, const Vector3 &amp;localDirectionVector=Vector3::NEGATIVE_UNIT_Z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::setDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_LOCAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localDirectionVector</em> = <code><a class="el" href="classOgre_1_1Vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the node's direction vector ie it's local -z. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The direction vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space in which this direction vector is expressed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>localDirectionVector</em>&nbsp;</td><td>The vector which normally describes the natural direction of the node, usually -Z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4749203fd450de6af6af90353714b87a"></a><!-- doxytag: member="Ogre::SceneNode::setDirection" ref="a4749203fd450de6af6af90353714b87a" args="(Real x, Real y, Real z, TransformSpace relativeTo=TS_LOCAL, const Vector3 &amp;localDirectionVector=Vector3::NEGATIVE_UNIT_Z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::setDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_LOCAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localDirectionVector</em> = <code><a class="el" href="classOgre_1_1Vector3.html#abdeebea4e94e114215a51831f9792f19">Vector3::NEGATIVE_UNIT_Z</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the node's direction vector ie it's local -z. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x,y,z</em>&nbsp;</td><td>The components of the direction vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space in which this direction vector is expressed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>localDirectionVector</em>&nbsp;</td><td>The vector which normally describes the natural direction of the node, usually -Z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47e1d67d84fc3287594fe139097d87a3"></a><!-- doxytag: member="Ogre::SceneNode::setFixedYawAxis" ref="a47e1d67d84fc3287594fe139097d87a3" args="(bool useFixed, const Vector3 &amp;fixedAxis=Vector3::UNIT_Y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::setFixedYawAxis </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useFixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fixedAxis</em> = <code><a class="el" href="classOgre_1_1Vector3.html#a8d1a1f7af535bcc8d9c78b1732bc1b90">Vector3::UNIT_Y</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method allows you to change the yaw behaviour of the node - by default, it yaws around it's own local Y axis when told to yaw with TS_LOCAL, this makes it yaw around a fixed axis. You only really need this when you're using auto tracking (see setAutoTracking, because when you're manually rotating a node you can specify the TransformSpace in which you wish to work anyway. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>useFixed</em>&nbsp;</td><td>If true, the axis passed in the second parameter will always be the yaw axis no matter what the node orientation. If false, the node returns to it's default behaviour. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fixedAxis</em>&nbsp;</td><td>The axis to use if the first parameter is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8398b5ae334ba06e99c16336fc750f9c"></a><!-- doxytag: member="Ogre::SceneNode::setInheritOrientation" ref="a8398b5ae334ba06e99c16336fc750f9c" args="(bool inherit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inherit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the node whether it should inherit orientation from it's parent node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inherit</em>&nbsp;</td><td>If true, this node's orientation will be affected by its parent's orientation. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a646e069c1b418cc820e814209abbf418"></a><!-- doxytag: member="Ogre::SceneNode::setInheritScale" ref="a646e069c1b418cc820e814209abbf418" args="(bool inherit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setInheritScale </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inherit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the node whether it should inherit scaling factors from it's parent node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inherit</em>&nbsp;</td><td>If true, this node's scale will be affected by its parent's scale. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8119af87243123929da530b01dd54fd4"></a><!-- doxytag: member="Ogre::SceneNode::setInitialState" ref="a8119af87243123929da530b01dd54fd4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setInitialState </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the current transform of this node to be the 'initial state' ie that position / orientation / scale to be used as a basis for delta values used in keyframe animation. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>You never need to call this method unless you plan to animate this node. If you do plan to animate it, call this method once you've loaded the node with it's base state, ie the state on which all keyframes are based. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If you never call this method, the initial state is the identity transform, ie do nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a5249598f9b893ac14dee5e4bae8622d4"></a><!-- doxytag: member="Ogre::SceneNode::setInSceneGraph" ref="a5249598f9b893ac14dee5e4bae8622d4" args="(bool inGraph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::setInSceneGraph </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inGraph</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method for setting whether the node is in the scene graph. </p>

</div>
</div>
<a class="anchor" id="ac958f0d4fad0970aa65bdd0f86de6781"></a><!-- doxytag: member="Ogre::SceneNode::setListener" ref="ac958f0d4fad0970aa65bdd0f86de6781" args="(Listener *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node_1_1Listener.html">Listener</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a listener for this <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Note for size and performance reasons only one listener per node is allowed. </dd></dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00660">660</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a412b900632a24e3e8a90c25a5d78d84c"></a><!-- doxytag: member="Ogre::SceneNode::setOrientation" ref="a412b900632a24e3e8a90c25a5d78d84c" args="(Real w, Real x, Real y, Real z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the orientation of this node via quaternion parameters. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="aadc391905c7c4ea06b8f5366b6ad10d2"></a><!-- doxytag: member="Ogre::SceneNode::setOrientation" ref="aadc391905c7c4ea06b8f5366b6ad10d2" args="(const Quaternion &amp;q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the orientation of this node via a quaternion. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ab0426279d3d191c4c82e21fe59d388"></a><!-- doxytag: member="Ogre::SceneNode::setParent" ref="a9ab0426279d3d191c4c82e21fe59d388" args="(Node *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

<p>Reimplemented from <a class="el" href="classOgre_1_1Node.html#a723f17db93678b3481c86236abb955a7">Ogre::Node</a>.</p>

</div>
</div>
<a class="anchor" id="a37e99410b2de7a2957a4782d8f8ac623"></a><!-- doxytag: member="Ogre::SceneNode::setPosition" ref="a37e99410b2de7a2957a4782d8f8ac623" args="(Real x, Real y, Real z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the position of the node relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="a0064d0828b70b9fd197a7128fbf5b94e"></a><!-- doxytag: member="Ogre::SceneNode::setPosition" ref="a0064d0828b70b9fd197a7128fbf5b94e" args="(const Vector3 &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the position of the node relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="a5edf4ac8499f761b324fbf4197e77946"></a><!-- doxytag: member="Ogre::SceneNode::setScale" ref="a5edf4ac8499f761b324fbf4197e77946" args="(Real x, Real y, Real z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the scaling factor applied to this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="ad44befdae5ff835dc44db4adcaaee20b"></a><!-- doxytag: member="Ogre::SceneNode::setScale" ref="ad44befdae5ff835dc44db4adcaaee20b" args="(const Vector3 &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the scaling factor applied to this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3a25fc37acf61b1b4fd1716c0196ee1"></a><!-- doxytag: member="Ogre::SceneNode::setUserAny" ref="aa3a25fc37acf61b1b4fd1716c0196ee1" args="(const Any &amp;anything)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::setUserAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Any.html">Any</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anything</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>use <a class="el" href="classOgre_1_1UserObjectBindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a> via <a class="el" href="classOgre_1_1Node.html#af3fcf16e43b07e046816125cbb8dc8f3" title="Return an instance of user objects binding associated with this class.">getUserObjectBindings()</a> instead. Sets any kind of user value on this object. </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method allows you to associate any user value you like with this <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. This can be a pointer back to one of your own classes for instance. </dd></dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00749">749</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada725e7b64b51803eaedbe28d7c8195e"></a><!-- doxytag: member="Ogre::SceneNode::setVisible" ref="ada725e7b64b51803eaedbe28d7c8195e" args="(bool visible, bool cascade=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>visible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>cascade</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes all objects attached to this node become visible / invisible. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a shortcut to calling <a class="el" href="classOgre_1_1SceneNode.html#ada725e7b64b51803eaedbe28d7c8195e" title="Makes all objects attached to this node become visible / invisible.">setVisible()</a> on the objects attached to this node, and optionally to all objects attached to child nodes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>visible</em>&nbsp;</td><td>Whether the objects are to be made visible or invisible </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cascade</em>&nbsp;</td><td>If true, this setting cascades into child nodes too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f9b0eb8efad4b5dd4130dec5b9fd749"></a><!-- doxytag: member="Ogre::SceneNode::showBoundingBox" ref="a0f9b0eb8efad4b5dd4130dec5b9fd749" args="(bool bShow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::showBoundingBox </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bShow</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the showing of the node's bounding box. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Use this to show or hide the bounding box of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c147221e3963295853affdc2cd06c81"></a><!-- doxytag: member="Ogre::SceneNode::translate" ref="a4c147221e3963295853affdc2cd06c81" args="(const Matrix3 &amp;axes, Real x, Real y, Real z, TransformSpace relativeTo=TS_PARENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix3.html">Matrix3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_PARENT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the node along arbitrary axes. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method translates the node by a vector which is relative to a custom set of axes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>A 3x3 Matrix containg 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as </p>
<pre>
                1 0 0
                0 1 0
                0 0 1
                </pre><p> i.e. the identity matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x,y,z</em>&nbsp;</td><td>Translation components relative to the axes above. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac56415737b8d9a93a3a7f177b22602aa"></a><!-- doxytag: member="Ogre::SceneNode::translate" ref="ac56415737b8d9a93a3a7f177b22602aa" args="(const Matrix3 &amp;axes, const Vector3 &amp;move, TransformSpace relativeTo=TS_PARENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix3.html">Matrix3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_PARENT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the node along arbitrary axes. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method translates the node by a vector which is relative to a custom set of axes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>A 3x3 Matrix containg 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as: </p>
<pre>
                1 0 0
                0 1 0
                0 0 1
                </pre><p> i.e. the identity matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>move</em>&nbsp;</td><td>Vector relative to the axes above. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b11cb1ea6e2aba1832a56c4ed87f1dd"></a><!-- doxytag: member="Ogre::SceneNode::translate" ref="a4b11cb1ea6e2aba1832a56c4ed87f1dd" args="(Real x, Real y, Real z, TransformSpace relativeTo=TS_PARENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_PARENT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the node along the Cartesian axes. </p>
<dl class="user"><dt><b></b></dt><dd>This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>Real x, y and z values representing the translation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67b66f5a377603498e8a45bb5cab61b9"></a><!-- doxytag: member="Ogre::SceneNode::translate" ref="a67b66f5a377603498e8a45bb5cab61b9" args="(const Vector3 &amp;d, TransformSpace relativeTo=TS_PARENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_PARENT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the node along the Cartesian axes. </p>
<dl class="user"><dt><b></b></dt><dd>This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>Vector with x,y,z values representing the translation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ed30b55e585e35788ff947146a5d839"></a><!-- doxytag: member="Ogre::SceneNode::updateFromParentImpl" ref="a6ed30b55e585e35788ff947146a5d839" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneNode::updateFromParentImpl </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class-specific implementation of _updateFromParent. <dl class="remark"><dt><b>Remarks:</b></dt><dd>Splitting the implementation of the update away from the update call itself allows the detail to be overridden without disrupting the general sequence of updateFromParent (e.g. raising events) </dd></dl>
. </p>

<p>Reimplemented from <a class="el" href="classOgre_1_1Node.html#a0ac36d0da89457a557c429f1a9f7b704">Ogre::Node</a>.</p>

</div>
</div>
<a class="anchor" id="a0893a9cf482387e50a10d7b2d117efbb"></a><!-- doxytag: member="Ogre::SceneNode::yaw" ref="a0893a9cf482387e50a10d7b2d117efbb" args="(const Radian &amp;angle, TransformSpace relativeTo=TS_LOCAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneNode::yaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Node.html#ac42e2063379286eb673eaffff6ca5e99">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TS_LOCAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around the Y-axis. </p>

<p>Reimplemented from <a class="el" href="classOgre_1_1Node.html#af0d40ab6711058fa41ec905888587b32">Ogre::Node</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3718047a30a7575e283604ae27bdc31b"></a><!-- doxytag: member="Ogre::SceneNode::mAutoTrackLocalDirection" ref="a3718047a30a7575e283604ae27bdc31b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1SceneNode.html#a3718047a30a7575e283604ae27bdc31b">Ogre::SceneNode::mAutoTrackLocalDirection</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Local 'normal' direction vector. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00106">106</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79a962278ebfd05a0371659f0915650e"></a><!-- doxytag: member="Ogre::SceneNode::mAutoTrackOffset" ref="a79a962278ebfd05a0371659f0915650e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1SceneNode.html#a79a962278ebfd05a0371659f0915650e">Ogre::SceneNode::mAutoTrackOffset</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tracking offset for fine tuning. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00104">104</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad5ab7b1d824dc3be02e1f116d0801b40"></a><!-- doxytag: member="Ogre::SceneNode::mAutoTrackTarget" ref="ad5ab7b1d824dc3be02e1f116d0801b40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* <a class="el" href="classOgre_1_1SceneNode.html#ad5ab7b1d824dc3be02e1f116d0801b40">Ogre::SceneNode::mAutoTrackTarget</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Auto tracking target. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00102">102</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88c50934c653fd86447cc81da0998e81"></a><!-- doxytag: member="Ogre::SceneNode::mCachedTransform" ref="a88c50934c653fd86447cc81da0998e81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> <a class="el" href="classOgre_1_1Node.html#a88c50934c653fd86447cc81da0998e81">Ogre::Node::mCachedTransform</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cached derived transform as a 4x4 matrix. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00223">223</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="abeb1d94ee7b8cd7a612a30b510ccee6d"></a><!-- doxytag: member="Ogre::SceneNode::mCachedTransformOutOfDate" ref="abeb1d94ee7b8cd7a612a30b510ccee6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Node.html#abeb1d94ee7b8cd7a612a30b510ccee6d">Ogre::Node::mCachedTransformOutOfDate</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00224">224</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad508313713b823331eca7a3f6a4fd002"></a><!-- doxytag: member="Ogre::SceneNode::mChildren" ref="ad508313713b823331eca7a3f6a4fd002" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Node.html#ad926e6275c4c0ebe1e28eda5826c2945">ChildNodeMap</a> <a class="el" href="classOgre_1_1Node.html#ad508313713b823331eca7a3f6a4fd002">Ogre::Node::mChildren</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Collection of pointers to direct children; hashmap for efficiency. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00127">127</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a54aa00f1ca77a93516bc2d1b08b30648"></a><!-- doxytag: member="Ogre::SceneNode::mChildrenToUpdate" ref="a54aa00f1ca77a93516bc2d1b08b30648" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Node.html#aeeff7ca93bca86e92195a69a2cdfe502">ChildUpdateSet</a> <a class="el" href="classOgre_1_1Node.html#a54aa00f1ca77a93516bc2d1b08b30648">Ogre::Node::mChildrenToUpdate</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of children which need updating, used if self is not out of date but children are. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00131">131</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ed43b1903a0255a82ee41571b3ac108"></a><!-- doxytag: member="Ogre::SceneNode::mCreator" ref="a3ed43b1903a0255a82ee41571b3ac108" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a>* <a class="el" href="classOgre_1_1SceneNode.html#a3ed43b1903a0255a82ee41571b3ac108">Ogre::SceneNode::mCreator</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> which created this node. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00074">74</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac6d7568e730aee21dd64702afa03ba4d"></a><!-- doxytag: member="Ogre::SceneNode::mDebug" ref="ac6d7568e730aee21dd64702afa03ba4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Node_1_1DebugRenderable.html">DebugRenderable</a>* <a class="el" href="classOgre_1_1Node.html#ac6d7568e730aee21dd64702afa03ba4d">Ogre::Node::mDebug</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00232">232</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d7d9e45beb547ba72ce33f0274c1167"></a><!-- doxytag: member="Ogre::SceneNode::mDerivedOrientation" ref="a7d7d9e45beb547ba72ce33f0274c1167" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> <a class="el" href="classOgre_1_1Node.html#a7d7d9e45beb547ba72ce33f0274c1167">Ogre::Node::mDerivedOrientation</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cached combined orientation. </p>
<dl class="user"><dt><b></b></dt><dd>This member is the orientation derived by combining the local transformations and those of it's parents. This is updated when _updateFromParent is called by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> or the nodes parent. </dd></dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00172">172</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7fc19ff96fcb001d6e9981f439bb0eed"></a><!-- doxytag: member="Ogre::SceneNode::mDerivedPosition" ref="a7fc19ff96fcb001d6e9981f439bb0eed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1Node.html#a7fc19ff96fcb001d6e9981f439bb0eed">Ogre::Node::mDerivedPosition</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cached combined position. </p>
<dl class="user"><dt><b></b></dt><dd>This member is the position derived by combining the local transformations and those of it's parents. This is updated when _updateFromParent is called by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> or the nodes parent. </dd></dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00181">181</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2e5ca471f5154645a596cd230ea94af2"></a><!-- doxytag: member="Ogre::SceneNode::mDerivedScale" ref="a2e5ca471f5154645a596cd230ea94af2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1Node.html#a2e5ca471f5154645a596cd230ea94af2">Ogre::Node::mDerivedScale</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cached combined scale. </p>
<dl class="user"><dt><b></b></dt><dd>This member is the position derived by combining the local transformations and those of it's parents. This is updated when _updateFromParent is called by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> or the nodes parent. </dd></dl>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00190">190</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6f7d07c6abffa9ab419165696471a874"></a><!-- doxytag: member="Ogre::SceneNode::mHideBoundingBox" ref="a6f7d07c6abffa9ab419165696471a874" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneNode.html#a6f7d07c6abffa9ab419165696471a874">Ogre::SceneNode::mHideBoundingBox</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00071">71</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad85766c2f287598bb1059e84ce73e7bb"></a><!-- doxytag: member="Ogre::SceneNode::mInheritOrientation" ref="ad85766c2f287598bb1059e84ce73e7bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Node.html#ad85766c2f287598bb1059e84ce73e7bb">Ogre::Node::mInheritOrientation</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores whether this node inherits orientation from it's parent. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00157">157</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab10376524767e0b8a9e86964956f0b40"></a><!-- doxytag: member="Ogre::SceneNode::mInheritScale" ref="ab10376524767e0b8a9e86964956f0b40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Node.html#ab10376524767e0b8a9e86964956f0b40">Ogre::Node::mInheritScale</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores whether this node inherits scale from it's parent. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00160">160</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88590f5a049463362c0d2cec07bdca39"></a><!-- doxytag: member="Ogre::SceneNode::mInitialOrientation" ref="a88590f5a049463362c0d2cec07bdca39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> <a class="el" href="classOgre_1_1Node.html#a88590f5a049463362c0d2cec07bdca39">Ogre::Node::mInitialOrientation</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The orientation to use as a base for keyframe animation. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00218">218</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa23946bc6edd30b225a2f04170f04c89"></a><!-- doxytag: member="Ogre::SceneNode::mInitialPosition" ref="aa23946bc6edd30b225a2f04170f04c89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1Node.html#aa23946bc6edd30b225a2f04170f04c89">Ogre::Node::mInitialPosition</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The position to use as a base for keyframe animation. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00216">216</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f7a0ccee23accbece0017bec7dcd1ad"></a><!-- doxytag: member="Ogre::SceneNode::mInitialScale" ref="a3f7a0ccee23accbece0017bec7dcd1ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1Node.html#a3f7a0ccee23accbece0017bec7dcd1ad">Ogre::Node::mInitialScale</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The scale to use as a base for keyframe animation. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00220">220</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="abde5946531210225faafcf92b7eb4660"></a><!-- doxytag: member="Ogre::SceneNode::mIsInSceneGraph" ref="abde5946531210225faafcf92b7eb4660" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneNode.html#abde5946531210225faafcf92b7eb4660">Ogre::SceneNode::mIsInSceneGraph</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is this node a current part of the scene graph? </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00108">108</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cff3c3bdbe9243a4fd8d928c93365d0"></a><!-- doxytag: member="Ogre::SceneNode::mListener" ref="a4cff3c3bdbe9243a4fd8d928c93365d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Node_1_1Listener.html">Listener</a>* <a class="el" href="classOgre_1_1Node.html#a4cff3c3bdbe9243a4fd8d928c93365d0">Ogre::Node::mListener</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> listener - only one allowed (no list) for size &amp; performance reasons. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00227">227</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6580e36ab5bbec5d074efe6bfe0dcd79"></a><!-- doxytag: member="Ogre::SceneNode::mName" ref="a6580e36ab5bbec5d074efe6bfe0dcd79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1Node.html#a6580e36ab5bbec5d074efe6bfe0dcd79">Ogre::Node::mName</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Friendly name of this node, can be automatically generated if you don't care. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00142">142</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d4eff00d6dbea91264b52046cc367b5"></a><!-- doxytag: member="Ogre::SceneNode::mNeedChildUpdate" ref="a4d4eff00d6dbea91264b52046cc367b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Node.html#a4d4eff00d6dbea91264b52046cc367b5">Ogre::Node::mNeedChildUpdate</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag indicating that all children need to be updated. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00135">135</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae964b315ed79aef118b71b4c3b6466cd"></a><!-- doxytag: member="Ogre::SceneNode::mNeedParentUpdate" ref="ae964b315ed79aef118b71b4c3b6466cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Node.html#ae964b315ed79aef118b71b4c3b6466cd">Ogre::Node::mNeedParentUpdate</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate own transform from parent is out of date. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00133">133</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a92ed6ce65738128bee3cfcbb9074dab7"></a><!-- doxytag: member="Ogre::SceneNode::mObjectsByName" ref="a92ed6ce65738128bee3cfcbb9074dab7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneNode.html#a49043fde03f6003b0cfe1a65f2ff64df">ObjectMap</a> <a class="el" href="classOgre_1_1SceneNode.html#a92ed6ce65738128bee3cfcbb9074dab7">Ogre::SceneNode::mObjectsByName</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00065">65</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c40bc581d9ebbbf7e2d056c2bc8ffde"></a><!-- doxytag: member="Ogre::SceneNode::mOrientation" ref="a2c40bc581d9ebbbf7e2d056c2bc8ffde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> <a class="el" href="classOgre_1_1Node.html#a2c40bc581d9ebbbf7e2d056c2bc8ffde">Ogre::Node::mOrientation</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores the orientation of the node relative to it's parent. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00148">148</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a24d11a360b70ac6f37e4287bfbc223f7"></a><!-- doxytag: member="Ogre::SceneNode::mParent" ref="a24d11a360b70ac6f37e4287bfbc223f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Node.html">Node</a>* <a class="el" href="classOgre_1_1Node.html#a24d11a360b70ac6f37e4287bfbc223f7">Ogre::Node::mParent</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to parent node. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00125">125</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab270a19a8d2466230f5906883534d1b0"></a><!-- doxytag: member="Ogre::SceneNode::mParentNotified" ref="ab270a19a8d2466230f5906883534d1b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Node.html#ab270a19a8d2466230f5906883534d1b0">Ogre::Node::mParentNotified</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag indicating that parent has been notified about update request. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00137">137</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9ef4388bfc132db4a7f6a55f0352166e"></a><!-- doxytag: member="Ogre::SceneNode::mPosition" ref="a9ef4388bfc132db4a7f6a55f0352166e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1Node.html#a9ef4388bfc132db4a7f6a55f0352166e">Ogre::Node::mPosition</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores the position/translation of the node relative to its parent. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00151">151</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a64114e8a49a4db05074790280dc30cf0"></a><!-- doxytag: member="Ogre::SceneNode::mQueuedForUpdate" ref="a64114e8a49a4db05074790280dc30cf0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Node.html#a64114e8a49a4db05074790280dc30cf0">Ogre::Node::mQueuedForUpdate</a><code> [mutable, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag indicating that the node has been queued for update. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00139">139</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a858fbfaad27833ca00f8d0a1adf3093a"></a><!-- doxytag: member="Ogre::SceneNode::mScale" ref="a858fbfaad27833ca00f8d0a1adf3093a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1Node.html#a858fbfaad27833ca00f8d0a1adf3093a">Ogre::Node::mScale</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores the scaling factor applied to this node. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00154">154</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2a23d7a4772313b1d4568b946dfe23a0"></a><!-- doxytag: member="Ogre::SceneNode::mShowBoundingBox" ref="a2a23d7a4772313b1d4568b946dfe23a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneNode.html#a2a23d7a4772313b1d4568b946dfe23a0">Ogre::SceneNode::mShowBoundingBox</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag that determines if the bounding box of the node should be displayed. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00070">70</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab685c7e9f419db77e0f85331ea3cdca3"></a><!-- doxytag: member="Ogre::SceneNode::msNameGenerator" ref="ab685c7e9f419db77e0f85331ea3cdca3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1NameGenerator.html">NameGenerator</a> <a class="el" href="classOgre_1_1Node.html#ab685c7e9f419db77e0f85331ea3cdca3">Ogre::Node::msNameGenerator</a><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Incremented count for next name extension. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00145">145</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab0bc2321f649cd0165a442e7d3a8ad6e"></a><!-- doxytag: member="Ogre::SceneNode::msQueuedUpdates" ref="ab0bc2321f649cd0165a442e7d3a8ad6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Node.html#a747a039791396b55d96c8251186b05cd">QueuedUpdates</a> <a class="el" href="classOgre_1_1Node.html#ab0bc2321f649cd0165a442e7d3a8ad6e">Ogre::Node::msQueuedUpdates</a><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00230">230</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a231ea555d7cc14a041557df9b63d667c"></a><!-- doxytag: member="Ogre::SceneNode::mUserObjectBindings" ref="a231ea555d7cc14a041557df9b63d667c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a> <a class="el" href="classOgre_1_1Node.html#a231ea555d7cc14a041557df9b63d667c">Ogre::Node::mUserObjectBindings</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>User objects binding. </p>

<p>Definition at line <a class="el" href="OgreNode_8h_source.html#l00235">235</a> of file <a class="el" href="OgreNode_8h_source.html">OgreNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab63dc19d99002d2634db61fdfb2042bc"></a><!-- doxytag: member="Ogre::SceneNode::mWireBoundingBox" ref="ab63dc19d99002d2634db61fdfb2042bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1WireBoundingBox.html">WireBoundingBox</a>* <a class="el" href="classOgre_1_1SceneNode.html#ab63dc19d99002d2634db61fdfb2042bc">Ogre::SceneNode::mWireBoundingBox</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to a Wire Bounding <a class="el" href="structOgre_1_1Box.html" title="Structure used to define a box in a 3-D integer space.">Box</a> for this <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00068">68</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="aae5a245a9ef39e8a32f15360b7404d92"></a><!-- doxytag: member="Ogre::SceneNode::mWorldAABB" ref="aae5a245a9ef39e8a32f15360b7404d92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a> <a class="el" href="classOgre_1_1SceneNode.html#aae5a245a9ef39e8a32f15360b7404d92">Ogre::SceneNode::mWorldAABB</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>World-Axis aligned bounding box, updated only through _update. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00077">77</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79fe2c7ff9599191a58902cdae1b3a3f"></a><!-- doxytag: member="Ogre::SceneNode::mYawFixed" ref="a79fe2c7ff9599191a58902cdae1b3a3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneNode.html#a79fe2c7ff9599191a58902cdae1b3a3f">Ogre::SceneNode::mYawFixed</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether to yaw around a fixed axis. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00097">97</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a37db788390eb6da498e0e4bfeb2400e1"></a><!-- doxytag: member="Ogre::SceneNode::mYawFixedAxis" ref="a37db788390eb6da498e0e4bfeb2400e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1SceneNode.html#a37db788390eb6da498e0e4bfeb2400e1">Ogre::SceneNode::mYawFixedAxis</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fixed axis to yaw around. </p>

<p>Definition at line <a class="el" href="OgreSceneNode_8h_source.html#l00099">99</a> of file <a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreSceneNode_8h_source.html">OgreSceneNode.h</a></li>
</ul>
</div>
<hr>
<p>
Copyright &copy; 2008 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Wed Nov 3 20:33:20 2010
</p>
</body>
</html>
