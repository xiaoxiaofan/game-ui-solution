<html>
<head>
<title>OGRE: OgreMemoryAllocatorConfig.h File Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_7cb42e7d1b792c5da77a6194d9d1e401.html">OgreMain</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_06adfb76b2c2313861d66efb0398843d.html">include</a>
  </div>
</div>
<div class="contents">
<h1>OgreMemoryAllocatorConfig.h File Reference</h1>
<p>This file configures Ogre's memory allocators.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="OgreMemorySTLAllocator_8h_source.html">OgreMemorySTLAllocator.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="OgreMemoryNedPooling_8h_source.html">OgreMemoryNedPooling.h</a>&quot;</code><br/>

<p><a href="OgreMemoryAllocatorConfig_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy&lt; Cat &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy&lt; Cat, align &gt;</a></td></tr>
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html">Ogre</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga2382b731c3d757f74f0fedf2b14ed9d6">OGRE_MALLOC</a>(bytes, category)&nbsp;&nbsp;&nbsp;::<a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of raw memory, and indicate the category of usage.  <a href="group__Memory.html#ga2382b731c3d757f74f0fedf2b14ed9d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga3211e4a6a806aa789b38dce2432ef472">OGRE_ALLOC_T</a>(T, count, category)&nbsp;&nbsp;&nbsp;static_cast&lt;T*&gt;(::<a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(count)))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory for a primitive type, and indicate the category of usage.  <a href="group__Memory.html#ga3211e4a6a806aa789b38dce2432ef472"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gacfd8dc937cf390c7bff05495f0dc10cf">OGRE_FREE</a>(ptr, category)&nbsp;&nbsp;&nbsp;::<a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((void*)ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with OGRE_MALLOC or OGRE_ALLOC_T. Category is required to be restated to ensure the matching policy is used.  <a href="group__Memory.html#gacfd8dc937cf390c7bff05495f0dc10cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga46253f12658ce0922e982a8a9dd11312">OGRE_NEW_T</a>(T, category)&nbsp;&nbsp;&nbsp;new (::<a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T))) T</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate space for one primitive type, external type or non-virtual type with constructor parameters.  <a href="group__Memory.html#ga46253f12658ce0922e982a8a9dd11312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga6c428bbdad197df6a4ba22d3c1d48f5a">OGRE_NEW_ARRAY_T</a>(T, count, category)&nbsp;&nbsp;&nbsp;::Ogre::constructN(static_cast&lt;T*&gt;(::<a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(count))), count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory for 'count' primitive types - do not use for classes that inherit from AllocatedObject.  <a href="group__Memory.html#ga6c428bbdad197df6a4ba22d3c1d48f5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga0b0974da65362dd8a14071e7f6e4daca">OGRE_DELETE_T</a>(ptr, T, category)&nbsp;&nbsp;&nbsp;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((void*)ptr);}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_T. Category is required to be restated to ensure the matching policy is used.  <a href="group__Memory.html#ga0b0974da65362dd8a14071e7f6e4daca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gab9f9fa14d424036dc5881cbcb3c741e0">OGRE_DELETE_ARRAY_T</a>(ptr, T, count, category)&nbsp;&nbsp;&nbsp;if(ptr){for (size_t b = 0; b &lt; count; ++b) { (ptr)[b].~T();} ::<a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((void*)ptr);}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_ARRAY_T. Category is required to be restated to ensure the matching policy is used, count and type to call destructor.  <a href="group__Memory.html#gab9f9fa14d424036dc5881cbcb3c741e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gafd7ddaef10ac9ea1ffbd18902167b9a2">OGRE_MALLOC_SIMD</a>(bytes, category)&nbsp;&nbsp;&nbsp;::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of raw memory aligned to SIMD boundaries, and indicate the category of usage.  <a href="group__Memory.html#gafd7ddaef10ac9ea1ffbd18902167b9a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga876cf0a4c7e209ce798b5e6708ca2343">OGRE_MALLOC_ALIGN</a>(bytes, category, align)&nbsp;&nbsp;&nbsp;::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of raw memory aligned to user defined boundaries, and indicate the category of usage.  <a href="group__Memory.html#ga876cf0a4c7e209ce798b5e6708ca2343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga728b719dd1425d46a78fe87d6f9ea6a5">OGRE_ALLOC_T_SIMD</a>(T, count, category)&nbsp;&nbsp;&nbsp;static_cast&lt;T*&gt;(::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(count)))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory for a primitive type aligned to SIMD boundaries, and indicate the category of usage.  <a href="group__Memory.html#ga728b719dd1425d46a78fe87d6f9ea6a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gafc79c14937612b02ac50631c08666b26">OGRE_ALLOC_T_ALIGN</a>(T, count, category, align)&nbsp;&nbsp;&nbsp;static_cast&lt;T*&gt;(::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T)*(count)))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory for a primitive type aligned to user defined boundaries, and indicate the category of usage.  <a href="group__Memory.html#gafc79c14937612b02ac50631c08666b26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gaf7501eb098fc6671420c628dc80af2a8">OGRE_FREE_SIMD</a>(ptr, category)&nbsp;&nbsp;&nbsp;::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((void*)ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with either OGRE_MALLOC_SIMD or OGRE_ALLOC_T_SIMD. Category is required to be restated to ensure the matching policy is used.  <a href="group__Memory.html#gaf7501eb098fc6671420c628dc80af2a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gaa06d37a211e3da357b8457ccdb4decac">OGRE_FREE_ALIGN</a>(ptr, category, align)&nbsp;&nbsp;&nbsp;::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((void*)ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with either OGRE_MALLOC_ALIGN or OGRE_ALLOC_T_ALIGN. Category is required to be restated to ensure the matching policy is used.  <a href="group__Memory.html#gaa06d37a211e3da357b8457ccdb4decac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga2f7eef98b7fe3ba9f36630b787d603b1">OGRE_NEW_T_SIMD</a>(T, category)&nbsp;&nbsp;&nbsp;new (::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T))) T</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate space for one primitive type, external type or non-virtual type aligned to SIMD boundaries.  <a href="group__Memory.html#ga2f7eef98b7fe3ba9f36630b787d603b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gaa55846bae98cf66fd5158ad0d4d623bb">OGRE_NEW_ARRAY_T_SIMD</a>(T, count, category)&nbsp;&nbsp;&nbsp;::Ogre::constructN(static_cast&lt;T*&gt;(::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(count))), count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory for 'count' primitive types aligned to SIMD boundaries - do not use for classes that inherit from AllocatedObject.  <a href="group__Memory.html#gaa55846bae98cf66fd5158ad0d4d623bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga1a5d598e538371f2fca9608277051347">OGRE_DELETE_T_SIMD</a>(ptr, T, category)&nbsp;&nbsp;&nbsp;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((void*)ptr);}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_T_SIMD. Category is required to be restated to ensure the matching policy is used.  <a href="group__Memory.html#ga1a5d598e538371f2fca9608277051347"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga3ceedc1e74432821ffab664232c12d04">OGRE_DELETE_ARRAY_T_SIMD</a>(ptr, T, count, category)&nbsp;&nbsp;&nbsp;if(ptr){for (size_t b = 0; b &lt; count; ++b) { (ptr)[b].~T();} ::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((void*)ptr);}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_ARRAY_T_SIMD. Category is required to be restated to ensure the matching policy is used, count and type to call destructor.  <a href="group__Memory.html#ga3ceedc1e74432821ffab664232c12d04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga4c928813aac2c96ae5cc775aacd3e26d">OGRE_NEW_T_ALIGN</a>(T, category, align)&nbsp;&nbsp;&nbsp;new (::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T))) T</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate space for one primitive type, external type or non-virtual type aligned to user defined boundaries.  <a href="group__Memory.html#ga4c928813aac2c96ae5cc775aacd3e26d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga51224b5c8af6fd85e192975ebe20139b">OGRE_NEW_ARRAY_T_ALIGN</a>(T, count, category, align)&nbsp;&nbsp;&nbsp;::Ogre::constructN(static_cast&lt;T*&gt;(::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T)*(count))), count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory for 'count' primitive types aligned to user defined boundaries - do not use for classes that inherit from AllocatedObject.  <a href="group__Memory.html#ga51224b5c8af6fd85e192975ebe20139b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga076af127ea8efe2284e03ab4c2057603">OGRE_DELETE_T_ALIGN</a>(ptr, T, category, align)&nbsp;&nbsp;&nbsp;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((void*)ptr);}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_T_ALIGN. Category is required to be restated to ensure the matching policy is used.  <a href="group__Memory.html#ga076af127ea8efe2284e03ab4c2057603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga25e1e9ce907fc367cc735465c940da23">OGRE_DELETE_ARRAY_T_ALIGN</a>(ptr, T, count, category, align)&nbsp;&nbsp;&nbsp;if(ptr){for (size_t _b = 0; _b &lt; count; ++_b) { (ptr)[_b].~T();} ::<a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((void*)ptr);}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_ARRAY_T_ALIGN. Category is required to be restated to ensure the matching policy is used, count and type to call destructor.  <a href="group__Memory.html#ga25e1e9ce907fc367cc735465c940da23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a>&nbsp;&nbsp;&nbsp;new</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#gad18eff671a00617b21c8e35a7f545690">OGRE_DELETE</a>&nbsp;&nbsp;&nbsp;delete</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CategorisedAllocPolicy<br class="typebreak"/>
&lt; Ogre::MEMCATEGORY_GENERAL &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ad4ca7bb13f62006a192960fda3b0151e">Ogre::GeneralAllocPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CategorisedAllocPolicy<br class="typebreak"/>
&lt; Ogre::MEMCATEGORY_GEOMETRY &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a89e5a164d08384010e03c34574474b4d">Ogre::GeometryAllocPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CategorisedAllocPolicy<br class="typebreak"/>
&lt; Ogre::MEMCATEGORY_ANIMATION &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a61c92fc2d65ecf3d3da5078c57f85f2a">Ogre::AnimationAllocPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CategorisedAllocPolicy<br class="typebreak"/>
&lt; Ogre::MEMCATEGORY_SCENE_CONTROL &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a8668cddbec3443fa8e571a3bde593524">Ogre::SceneCtlAllocPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CategorisedAllocPolicy<br class="typebreak"/>
&lt; Ogre::MEMCATEGORY_SCENE_OBJECTS &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a51f31eabec6808e2ff9c298d67617833">Ogre::SceneObjAllocPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CategorisedAllocPolicy<br class="typebreak"/>
&lt; Ogre::MEMCATEGORY_RESOURCE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a12051b505684557920b7caa1e87f17c8">Ogre::ResourceAllocPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CategorisedAllocPolicy<br class="typebreak"/>
&lt; Ogre::MEMCATEGORY_SCRIPTING &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a4d33fa1e6c6f52c506e061269a755289">Ogre::ScriptingAllocPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CategorisedAllocPolicy<br class="typebreak"/>
&lt; Ogre::MEMCATEGORY_RENDERSYS &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a585fa2d21e2525019ad062d76df8b719">Ogre::RenderSysAllocPolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatedObject<br class="typebreak"/>
&lt; GeneralAllocPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ac4ac6f663a23cea1dab0ed10688e45d8">Ogre::GeneralAllocatedObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatedObject<br class="typebreak"/>
&lt; GeometryAllocPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a1d51ee2afe2fd7bda6f20180ed1338f6">Ogre::GeometryAllocatedObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatedObject<br class="typebreak"/>
&lt; AnimationAllocPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a220b9754c8853bdb56aa4f6d2a2d2bec">Ogre::AnimationAllocatedObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatedObject<br class="typebreak"/>
&lt; SceneCtlAllocPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#aa225e5e6dcbf1073a8990eafdae4fb1c">Ogre::SceneCtlAllocatedObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatedObject<br class="typebreak"/>
&lt; SceneObjAllocPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a7af43449266010d92fd985d19d3f6483">Ogre::SceneObjAllocatedObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatedObject<br class="typebreak"/>
&lt; ResourceAllocPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#adb684516ccdc078fcab9afb5aaa3cdb3">Ogre::ResourceAllocatedObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatedObject<br class="typebreak"/>
&lt; ScriptingAllocPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a231968a1c453b90df9ab78080c4505da">Ogre::ScriptingAllocatedObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatedObject<br class="typebreak"/>
&lt; RenderSysAllocPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a58ac0addbec4db9072a7405d75e6bd57">Ogre::RenderSysAllocatedObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ScriptingAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ae50d0e41173a3de1eba795db887fc4c0">Ogre::AbstractNodeAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AnimationAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ae09578a5f721385da35583d80a40ff8f">Ogre::AnimableAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AnimationAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a45280f006598c2e3c01e1fa1eb1c0aeb">Ogre::AnimationAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a3a7148114d38cef237dc8bf95cb91cd3">Ogre::ArchiveAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeometryAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a8688596fd4772e25d4d24b91bd26fc3c">Ogre::BatchedGeometryAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RenderSysAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a4d5903ed39d36fb554acb8a14c4e941b">Ogre::BufferAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a62bd950b43a50257f8aa1589d2e823f9">Ogre::CodecAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ResourceAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a5d60f07603a9106ef3ea80c2436071e3">Ogre::CompositorInstAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a36fae75ecb951f16758e8f867e537318">Ogre::ConfigAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ac34508fbac0e38aa4bb253ccf0708c56">Ogre::ControllerAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeometryAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a6cb7d42eba87cebf8ccb40505b63377a">Ogre::DebugGeomAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a0a4a723194700acb950b79d7192c7639">Ogre::DynLibAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeometryAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a47d4cfd39390ea7f0bde7edff0a6423b">Ogre::EdgeDataAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#afab320e0856ce249ec1e1a4d404981ec">Ogre::FactoryAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneObjAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ac42757f609ae0b4aba4815a0e8084caa">Ogre::FXAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a1e40a7870ebd749e8cc8da346af3a3c8">Ogre::ImageAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeometryAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a2b83ab3362f4516b51f2a0238e8ac7c5">Ogre::IndexDataAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ad43ae31cfa3f0521786631f5ffe4c18a">Ogre::LogAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneObjAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a7f9d4a08ffbda0738cebc31b60faae03">Ogre::MovableAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneCtlAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ab81544a3d3f08a24fff526b288c4d5ba">Ogre::NodeAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneObjAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#afec5829b83af2dee85d271b16c5ab609">Ogre::OverlayAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RenderSysAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a9cd4601f9bf87a6bd2846370ccea6acb">Ogre::GpuParamsAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ResourceAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ae356a34e71ec1870afef50230739c7dc">Ogre::PassAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeometryAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#af63fccb4061ef6ab1a2b9b3085e3c92f">Ogre::PatchAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#abf9224e43c0858fdb5828c8dbbd58b05">Ogre::PluginAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a250dfc29da6341127d7d386e06101e67">Ogre::ProfilerAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeometryAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a48699950804f68c746cbefabf20a3fa7">Ogre::ProgMeshAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneCtlAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ab5b177f3272759202a585928bcd3906f">Ogre::RenderQueueAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RenderSysAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a1154f3f32829ce6787b6ac69569bf89b">Ogre::RenderSysAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#aaa653fbb322c81fdf7c29d8a621c0bfb">Ogre::RootAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ResourceAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a26f1823e78b0275e485bc519e4199480">Ogre::ResourceAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ab314a0c39a23a8ca15d867db9dd0f204">Ogre::SerializerAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneCtlAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ab5dc8e76f824d92c77fc11edd09f900b">Ogre::SceneMgtAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ScriptingAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a290b9222311de853679ae9efa942e713">Ogre::ScriptCompilerAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ScriptingAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a5553b2ac4d5a74c0dc16b4851418ebe6">Ogre::ScriptTranslatorAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneCtlAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a060a8fd0d2f2acb1e8da2820e60ecd0b">Ogre::ShadowDataAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ab1b4c43359603ea0d0cace50d6fc57ee">Ogre::StreamAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneObjAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a11c9152a33c78bdc13a9cfdc41833d35">Ogre::SubEntityAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ResourceAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a28c456e4a7bcbaf9afa7da4b59c3d18e">Ogre::SubMeshAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ResourceAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a14ad07d89fe48693b5abe86054702dbb">Ogre::TechniqueAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a2facde8318daf273780d84304f60cfa0">Ogre::TimerAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ResourceAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a2286e700a22b9e109cbf2aa95f9ce094">Ogre::TextureUnitStateAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeneralAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#af1b4f61252337a39768b2e8963551198">Ogre::UtilityAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef GeometryAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#ab030dab0a47bd28ac42be0260af08719">Ogre::VertexDataAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RenderSysAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a3d3ba82ee4ce61a447259f7c8a19cb2a">Ogre::ViewportAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SceneCtlAllocatedObject&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a5fae23475351938803d15fcbabc3b6d8">Ogre::LodAlloc</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga830fab51be174d6f2849857cb1abb36a">Ogre::MemoryCategory</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb">Ogre::MEMCATEGORY_GENERAL</a> =  0, 
<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aaf9e04ff475de4493bc942a9c73da4c2e">Ogre::MEMCATEGORY_GEOMETRY</a> =  1, 
<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa24267bedbd1115a8f208e4ee355693e4">Ogre::MEMCATEGORY_ANIMATION</a> =  2, 
<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8a55fa0fcaa8403bb51ca210f882ed90">Ogre::MEMCATEGORY_SCENE_CONTROL</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aaffe1e3d51d961175f8f2756611439181">Ogre::MEMCATEGORY_SCENE_OBJECTS</a> =  4, 
<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa04bad2e7f64cc2b6f4cda9f56b59e5b4">Ogre::MEMCATEGORY_RESOURCE</a> =  5, 
<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aaa037d2f843117cd5fb39ec064d7ff23b">Ogre::MEMCATEGORY_SCRIPTING</a> =  6, 
<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa29274489311d683a88676dbb1c779788">Ogre::MEMCATEGORY_RENDERSYS</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa4ff2b9446477e2ea4170b09d8aaa1b67">Ogre::MEMCATEGORY_COUNT</a> =  8
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>A set of categories that indicate the purpose of a chunk of memory being allocated. </p>
 <a href="group__Memory.html#ga830fab51be174d6f2849857cb1abb36a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Memory.html#ga9c9cabf026ea8517709d6dd09e085840">Ogre::constructN</a> (T *basePtr, size_t count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility function for constructing an array of objects with placement new, without using new[] (which allocates an undocumented amount of extra memory and so isn't appropriate for custom allocators).  <a href="group__Memory.html#ga9c9cabf026ea8517709d6dd09e085840"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOgre.html#a7495b1a18ca68ea4d46a955a9e8b8ae2">Ogre::deletePtr</a> (T *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function which invokes OGRE_DELETE on a given pointer.  <a href="#a7495b1a18ca68ea4d46a955a9e8b8ae2"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file configures Ogre's memory allocators. </p>
<p>You can modify this file to alter the allocation routines used for Ogre's main objects.</p>
<p>When customising memory allocation, all you need to do is provide one or more custom allocation policy classes. These classes need to implement:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Allocate bytes - file/line/func information should be optional, </span>
    <span class="comment">// will be provided when available but not everywhere (e.g. release mode, STL allocations)</span>
    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>* allocateBytes(<span class="keywordtype">size_t</span> count, <span class="keyword">const</span> <span class="keywordtype">char</span>* file = 0, <span class="keywordtype">int</span> line = 0, <span class="keyword">const</span> <span class="keywordtype">char</span>* func = 0);
    <span class="comment">// Free bytes</span>
    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> deallocateBytes(<span class="keywordtype">void</span>* ptr);
    <span class="comment">// Return the max number of bytes available to be allocated in a single allocation</span>
    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> getMaxAllocationSize();
</pre></div><p>Policies are then used as implementations for the wrapper classes and macros which call them. AllocatedObject for example provides the hooks to override the new and delete operators for a class and redirect the functionality to the policy. STLAllocator is a class which is provided to STL containers in order to hook up allocation of the containers members to the allocation policy. </p>
<dl class="user"><dt><b></b></dt><dd>In addition to linking allocations to policies, this class also defines a number of macros to allow debugging information to be passed along with allocations, such as the file and line number they originate from. It's important to realise that we do not redefine the 'new' and 'delete' symbols with macros, because that's very difficult to consistently do when other libraries are also trying to do the same thing; instead we use dedicated 'OGRE_' prefixed macros. See OGRE_NEW and related items. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The base macros you can use are listed below, in order of preference and with their conditions stated: <ul>
<li>
OGRE_NEW - use to allocate an object which have custom new/delete operators to handle custom allocations, usually this means it's derived from <a class="el" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new...">Ogre::AllocatedObject</a>. Free the memory using OGRE_DELETE. You can in fact use the regular new/delete for these classes but you won't get any line number debugging if you do. The memory category is automatically derived for these classes; for all other allocations you have to specify it.  </li>
<li>
OGRE_NEW_T - use to allocate a single class / struct that does not have custom new/delete operators, either because it is non-virtual (Vector3, Quaternion), or because it is from an external library (e.g. STL). You must deallocate with OGRE_DELETE_T if you expect the destructor to be called. You may free the memory using OGRE_FREE if you are absolutely sure there is no destructor to be called. These macros ensure that constructors and destructors are called correctly even though the memory originates externally (via placement new). Also note that you have to specify the type and memory category so that the correct allocator can be derived, when both allocating and freeing.  </li>
<li>
OGRE_NEW_ARRAY_T - as OGRE_NEW_T except with an extra parameter to construct multiple instances in contiguous memory. Again constructors and destructors are called. Free with OGRE_DELETE_ARRAY_T.  </li>
<li>
OGRE_ALLOC_T - use to allocate a set of primitive types conveniently with type safety. This <em>can</em> also be used for classes and structs but it is <b>imperative</b> that you understand that neither the constructor nor the destructor will be called. Sometimes you want this because it's more efficient just to grab/free a chunk of memory without having to iterate over each element constructing / destructing. Free the memory with OGRE_FREE.  </li>
<li>
OGRE_MALLOC - the most raw form of allocation, just a set of bytes. Use OGRE_FREE to release. </li>
<li>
_SIMD and _ALIGN variants - all of the above have variations which allow aligned memory allocations. The _SIMD versions align automatically to the SIMD requirements of your platform, the _ALIGN variants allow user-defined alignment to be specified.  </li>
</ul>
Here are some examples: <div class="fragment"><pre class="fragment">
    AllocatedClass* obj = <a class="code" href="group__Memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> AllocatedClass();
    <a class="code" href="group__Memory.html#gad18eff671a00617b21c8e35a7f545690">OGRE_DELETE</a> obj;
    AllocatedClass* array = <a class="code" href="group__Memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> AllocatedClass[10];
    <a class="code" href="group__Memory.html#gad18eff671a00617b21c8e35a7f545690">OGRE_DELETE</a> [] obj;
    ExternalClass* obj = <a class="code" href="group__Memory.html#ga46253f12658ce0922e982a8a9dd11312" title="Allocate space for one primitive type, external type or non-virtual type with constructor...">OGRE_NEW_T</a>(ExternalClass, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>)(constructorArgs);
    <a class="code" href="group__Memory.html#ga0b0974da65362dd8a14071e7f6e4daca" title="Free the memory allocated with OGRE_NEW_T. Category is required to be restated to...">OGRE_DELETE_T</a>(obj, ExternalClass, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
    ExternalClass* obj = <a class="code" href="group__Memory.html#ga6c428bbdad197df6a4ba22d3c1d48f5a" title="Allocate a block of memory for &amp;#39;count&amp;#39; primitive types - do not use for classes...">OGRE_NEW_ARRAY_T</a>(ExternalClass, 10, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
    <a class="code" href="group__Memory.html#gab9f9fa14d424036dc5881cbcb3c741e0" title="Free the memory allocated with OGRE_NEW_ARRAY_T. Category is required to be restated...">OGRE_DELETE_ARRAY_T</a>(obj, NonVirtualClass, 10, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
    <span class="keywordtype">long</span>* pLong = <a class="code" href="group__Memory.html#ga3211e4a6a806aa789b38dce2432ef472" title="Allocate a block of memory for a primitive type, and indicate the category of usage...">OGRE_ALLOC_T</a>(<span class="keywordtype">long</span>, 10, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
    <a class="code" href="group__Memory.html#gacfd8dc937cf390c7bff05495f0dc10cf" title="Free the memory allocated with OGRE_MALLOC or OGRE_ALLOC_T. Category is required...">OGRE_FREE</a>(pLong, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
    <span class="keywordtype">long</span>* pLong = <a class="code" href="group__Memory.html#ga46253f12658ce0922e982a8a9dd11312" title="Allocate space for one primitive type, external type or non-virtual type with constructor...">OGRE_NEW_T</a>(<span class="keywordtype">long</span>, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>)(0);
    <a class="code" href="group__Memory.html#gacfd8dc937cf390c7bff05495f0dc10cf" title="Free the memory allocated with OGRE_MALLOC or OGRE_ALLOC_T. Category is required...">OGRE_FREE</a>(pLong, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
    <span class="keywordtype">void</span>* pVoid = <a class="code" href="group__Memory.html#ga2382b731c3d757f74f0fedf2b14ed9d6" title="Allocate a block of raw memory, and indicate the category of usage.">OGRE_MALLOC</a>(1024, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
    <a class="code" href="group__Memory.html#gacfd8dc937cf390c7bff05495f0dc10cf" title="Free the memory allocated with OGRE_MALLOC or OGRE_ALLOC_T. Category is required...">OGRE_FREE</a>(pVoid, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
</pre></div> OGRE_ALLOC_T is also the route to go for allocating real primitive types like int &amp; float. You free the memory using OGRE_FREE, and both variants have SIMD and custom alignment variants. </dd></dl>

<p>Definition in file <a class="el" href="OgreMemoryAllocatorConfig_8h_source.html">OgreMemoryAllocatorConfig.h</a>.</p>
</div>
<hr>
<p>
Copyright &copy; 2008 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Wed Nov 3 20:30:30 2010
</p>
</body>
</html>
