<html>
<head>
<title>OGRE: Ogre::Technique Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceOgre.html">Ogre</a>::<a class="el" href="classOgre_1_1Technique.html">Technique</a>
  </div>
</div>
<div class="contents">
<h1>Ogre::Technique Class Reference<br/>
<small>
[<a class="el" href="group__Materials.html">Materials</a>]</small>
</h1><!-- doxytag: class="Ogre::Technique" --><!-- doxytag: inherits="Ogre::AllocatedObject" -->
<p>Class representing an approach to rendering this particular <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ogre::Technique:</div>
<div class="dynsection">
<div class="center"><img src="classOgre_1_1Technique__inherit__graph.gif" border="0" usemap="#Ogre_1_1Technique_inherit__map" alt="Inheritance graph"/></div>
<map name="Ogre_1_1Technique_inherit__map" id="Ogre_1_1Technique_inherit__map">
<area shape="rect" id="node2" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new..." alt="" coords="9,5,119,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classOgre_1_1Technique-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule controlling whether technique is deemed supported based on GPU device name.  <a href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule controlling whether technique is deemed supported based on GPU vendor.  <a href="structOgre_1_1Technique_1_1GPUVendorRule.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> { <a class="el" href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2dabd4cc2de655eff5194cda7ea50d00ee3">INCLUDE</a> =  0, 
<a class="el" href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2da043f697946b7a6d01bb858768e6646a3">EXCLUDE</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Directive used to manually control technique support based on the inclusion or exclusion of some factor. </p>
 <a href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt; <a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a> &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aa110f5f6056965bfb02099099fb46958">GPUVendorRuleList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1vector.html">vector</a><br class="typebreak"/>
&lt; <a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a> &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a98091dbc9cb06b40138458537c36e3ed">GPUDeviceNameRuleList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1VectorIterator.html">VectorIterator</a>&lt; <a class="el" href="classOgre_1_1Technique.html#a2578716e1f4b4cf2a9d3102a48aaf235">Passes</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a3b4640d3383f331657fd9ee05cb835c2">PassIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1VectorIterator.html">VectorIterator</a><br class="typebreak"/>
&lt; <a class="el" href="group__Materials.html#ga4c6928d029248ab4e1a4f999972baee8">IlluminationPassList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a77a239a5901d2c67add2e7cea0bf3468">IlluminationPassIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstVectorIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classOgre_1_1Technique.html#aa110f5f6056965bfb02099099fb46958">GPUVendorRuleList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a2497a0043902e9d2af0757d769da655c">GPUVendorRuleIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstVectorIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classOgre_1_1Technique.html#a98091dbc9cb06b40138458537c36e3ed">GPUDeviceNameRuleList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a63da4eb10f7272486a9806374b09bab6">GPUDeviceNameRuleIterator</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a4bf5eef2cd88abdf3408234f2bb0899c">Technique</a> (<a class="el" href="classOgre_1_1Material.html">Material</a> *parent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a4bf5eef2cd88abdf3408234f2bb0899c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a0e0fe6b1b297d9c8e81287d7c7a7b377">Technique</a> (<a class="el" href="classOgre_1_1Material.html">Material</a> *parent, const <a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;oth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a0e0fe6b1b297d9c8e81287d7c7a7b377"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a3942999affa2e3a81d122ac58f181f11">~Technique</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a7f64b7cc4743ee7cc5d6782ba687d841">isSupported</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates if this technique is supported by the current graphics card.  <a href="#a7f64b7cc4743ee7cc5d6782ba687d841"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#abec5e34e76944eb89ac0c6d370e3b1d5">_compile</a> (bool autoManageTextureUnits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal compilation method; see <a class="el" href="classOgre_1_1Material.html#a1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>.  <a href="#abec5e34e76944eb89ac0c6d370e3b1d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aa99b43fb531b833bc7e7ce939af2d069">checkGPURules</a> (<a class="el" href="classOgre_1_1StringUtil.html#a665d79932d54b48b83acff563de7a9e5">StringUtil::StrStreamType</a> &amp;errors)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for checking GPU vendor / device rules.  <a href="#aa99b43fb531b833bc7e7ce939af2d069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a55699308ac7d558e4715356270204078">checkHardwareSupport</a> (bool autoManageTextureUnits, <a class="el" href="classOgre_1_1StringUtil.html#a665d79932d54b48b83acff563de7a9e5">StringUtil::StrStreamType</a> &amp;compileErrors)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for checking hardware support.  <a href="#a55699308ac7d558e4715356270204078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a8143f16e1759f3b5731389d59a66f309">_compileIlluminationPasses</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for splitting the passes into illumination passes.  <a href="#a8143f16e1759f3b5731389d59a66f309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a51466b61bfe2dbcdb1afbf21b1dd3253">createPass</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> for this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a51466b61bfe2dbcdb1afbf21b1dd3253"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a3ce84da25bb6b5762af714adaf70874a">getPass</a> (unsigned short index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the given index.  <a href="#a3ce84da25bb6b5762af714adaf70874a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a70cead1f1ccc258c493306fb4570b522">getPass</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> matching name.  <a href="#a70cead1f1ccc258c493306fb4570b522"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a7c787f22ac8d5efceebb65ae35ac6ef4">getNumPasses</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of passes.  <a href="#a7c787f22ac8d5efceebb65ae35ac6ef4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#af6cff3e7cbf0b677433ca0a0da04c6aa">removePass</a> (unsigned short index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the given index.  <a href="#af6cff3e7cbf0b677433ca0a0da04c6aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a1eaae1583cf2e6e310ae911d34da00be">removeAllPasses</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all Passes from this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a1eaae1583cf2e6e310ae911d34da00be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a6fe998209ba33ea38fdcef68743d678c">movePass</a> (const unsigned short sourceIndex, const unsigned short destinationIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move a pass from source index to destination index.  <a href="#a6fe998209ba33ea38fdcef68743d678c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOgre_1_1VectorIterator.html">PassIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a84f0ff4e856f6965c7ae8dcab67e6cf2">getPassIterator</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets an iterator over the passes in this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a84f0ff4e856f6965c7ae8dcab67e6cf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOgre_1_1VectorIterator.html">IlluminationPassIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aa864634545c3b7d57888cb8118d4af0a">getIlluminationPassIterator</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets an iterator over the illumination-stage categorised passes.  <a href="#aa864634545c3b7d57888cb8118d4af0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Material.html">Material</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a603fb40984083fbdfa1bf570cc602563">getParent</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the parent <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  <a href="#a603fb40984083fbdfa1bf570cc602563"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ac251efbed20452a6efb1361ea5d27496">operator=</a> (const <a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded operator to copy on <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to another.  <a href="#ac251efbed20452a6efb1361ea5d27496"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aad5c43b5aa506b6304204f3874a251df">getResourceGroup</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the resource group of the ultimate parent <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  <a href="#aad5c43b5aa506b6304204f3874a251df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ad22ecac74653f9d1a4c955cf865f41d4">isTransparent</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> involves transparency.  <a href="#ad22ecac74653f9d1a4c955cf865f41d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a7411b79f49c7136a55bd17eef1cc53ce">isTransparentSortingEnabled</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting enabled.  <a href="#a7411b79f49c7136a55bd17eef1cc53ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a5ec64a0826b7dfac29aa945e6cebfcde">isTransparentSortingForced</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting forced.  <a href="#a5ec64a0826b7dfac29aa945e6cebfcde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a5833abf80056c4a18b6eafb137b590bb">_prepare</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal prepare method, derived from call to <a class="el" href="classOgre_1_1Resource.html#a350b287fa3e83a389221274f68760008" title="Prepares the resource for load, if it is not already.">Material::prepare</a>.  <a href="#a5833abf80056c4a18b6eafb137b590bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ad78f99fe8c81b1dffaf2d9bfc3cfabb4">_unprepare</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal unprepare method, derived from call to Material::unprepare.  <a href="#ad78f99fe8c81b1dffaf2d9bfc3cfabb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a92b98b4f291fa76b02d2adeb822998af">_load</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal load method, derived from call to <a class="el" href="classOgre_1_1Resource.html#a699d1c851f494a8d5d23d23b695ceb47" title="Loads the resource, if it is not already.">Material::load</a>.  <a href="#a92b98b4f291fa76b02d2adeb822998af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a73c19a7dd382f37226f307c3afc98794">_unload</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal unload method, derived from call to <a class="el" href="classOgre_1_1Resource.html#aa31bef1bfaa87731622e56f11b548e27" title="Unloads the resource; this is not permanent, the resource can be reloaded later if...">Material::unload</a>.  <a href="#a73c19a7dd382f37226f307c3afc98794"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aac374abdbf430a519dafb578f36239ff">isLoaded</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aa5ad18f720bba21676f3424ed7b2382d">_notifyNeedsRecompile</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the technique that it needs recompilation.  <a href="#aa5ad18f720bba21676f3424ed7b2382d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a4186641fe103b4ffcee48c708d1e8f42">getShadowCasterMaterial</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return this material specific shadow casting specific material  <a href="#a4186641fe103b4ffcee48c708d1e8f42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ac0e017f3810451861191fedfe1d51a30">setShadowCasterMaterial</a> (<a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a> val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this material specific shadow casting specific material  <a href="#ac0e017f3810451861191fedfe1d51a30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a7913e8419619f0b074e67a638d54eb0f">setShadowCasterMaterial</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this material specific shadow casting specific material  <a href="#a7913e8419619f0b074e67a638d54eb0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ae40e12c1d7a1a3194bdf5ad68ba58fd0">getShadowReceiverMaterial</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return this material specific shadow receiving specific material  <a href="#ae40e12c1d7a1a3194bdf5ad68ba58fd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a14cb59e4b8d1073f5379378ccf43f103">setShadowReceiverMaterial</a> (<a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a> val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this material specific shadow receiving specific material  <a href="#a14cb59e4b8d1073f5379378ccf43f103"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a03a7f4c6fa69c36b2b92a79917c34ace">setShadowReceiverMaterial</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this material specific shadow receiving specific material  <a href="#a03a7f4c6fa69c36b2b92a79917c34ace"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a1b7d1d264b34c50b7606c646415a50e8">setPointSize</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> ps)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the point size properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a1b7d1d264b34c50b7606c646415a50e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a28bab7548009bc18723bc0dc20a44f6a">setAmbient</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the ambient colour reflectance properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a28bab7548009bc18723bc0dc20a44f6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ac5d459624ede01672c78846825cc0f96">setAmbient</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;ambient)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the ambient colour reflectance properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#ac5d459624ede01672c78846825cc0f96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a177ced7bb28cba1562a6d036a1b692f9">setDiffuse</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the diffuse colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a177ced7bb28cba1562a6d036a1b692f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#af5e13d58c70bbeeb1708e1479185a959">setDiffuse</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;diffuse)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the diffuse colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#af5e13d58c70bbeeb1708e1479185a959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a7f58112618978a38cb9396936a54586a">setSpecular</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the specular colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a7f58112618978a38cb9396936a54586a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a0add9d092f47eb2b654d936a66902d00">setSpecular</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;specular)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the specular colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a0add9d092f47eb2b654d936a66902d00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aed27a55db91366ee2f95a608f946bc86">setShininess</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the shininess properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#aed27a55db91366ee2f95a608f946bc86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aa987bf7df6c05a27a25ee334527498a0">setSelfIllumination</a> (<a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the amount of self-illumination of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#aa987bf7df6c05a27a25ee334527498a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a9e5d7120bf501c5796bb461ec16ca22d">setSelfIllumination</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;selfIllum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the amount of self-illumination of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a9e5d7120bf501c5796bb461ec16ca22d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a8ccefe2b6bb5b6e66e2dcb081f92847f">setDepthCheckEnabled</a> (bool enabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> renders with depth-buffer checking on or not.  <a href="#a8ccefe2b6bb5b6e66e2dcb081f92847f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a17ab42d4b777c0782a2d0170ae5a0970">setDepthWriteEnabled</a> (bool enabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> renders with depth-buffer writing on or not.  <a href="#a17ab42d4b777c0782a2d0170ae5a0970"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a1f8f52bd7bc067a8f6dac99757063a06">setDepthFunction</a> (<a class="el" href="group__General.html#ga0212b4eb264f207d84c1df9425208c7a">CompareFunction</a> func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the function used to compare depth values when depth checking is on.  <a href="#a1f8f52bd7bc067a8f6dac99757063a06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a155d2bb172e767eab0880667b8669057">setColourWriteEnabled</a> (bool enabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not colour buffer writing is enabled for each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>.  <a href="#a155d2bb172e767eab0880667b8669057"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ae3ab7639e71d6118834a9164a7c1c8f9">setCullingMode</a> (<a class="el" href="group__General.html#gac173244ed7d950d0acd726e4f323ecdb">CullingMode</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the culling mode for each pass based on the 'vertex winding'.  <a href="#ae3ab7639e71d6118834a9164a7c1c8f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a9d9340f9b31f6189e28d62ab00937ab0">setManualCullingMode</a> (<a class="el" href="group__General.html#ga07ec94cf178172a6778223e6f70f23fc">ManualCullingMode</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the manual culling mode, performed by CPU rather than hardware.  <a href="#a9d9340f9b31f6189e28d62ab00937ab0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ab6f31b910ad3b0a22219210290622482">setLightingEnabled</a> (bool enabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not dynamic lighting is enabled for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>.  <a href="#ab6f31b910ad3b0a22219210290622482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a4c3bb63365c701842d4539e32cc1480e">setShadingMode</a> (<a class="el" href="group__General.html#ga7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the type of light shading required.  <a href="#a4c3bb63365c701842d4539e32cc1480e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a42c07e62db4e2cbeb75f8253b30e5c3b">setFog</a> (bool overrideScene, <a class="el" href="group__General.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> mode=FOG_NONE, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour=<a class="el" href="classOgre_1_1ColourValue.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a>, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> expDensity=0.001, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearStart=0.0, <a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearEnd=1.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the fogging mode applied to each pass.  <a href="#a42c07e62db4e2cbeb75f8253b30e5c3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a58b4e86384ca3e7a9f03c3fb2a5b3f0d">setDepthBias</a> (float constantBias, float slopeScaleBias)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the depth bias to be used for each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>.  <a href="#a58b4e86384ca3e7a9f03c3fb2a5b3f0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a67d7464ef321b859c33c3c1e9334c5f2">setTextureFiltering</a> (<a class="el" href="group__General.html#ga21a0186392e9c9ce16d29c5568a773c5">TextureFilterOptions</a> filterType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set texture filtering for every texture unit in every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>.  <a href="#a67d7464ef321b859c33c3c1e9334c5f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a60e62cb6b00f8ae9e9da077d0ecc08ec">setTextureAnisotropy</a> (unsigned int maxAniso)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the anisotropy level to be used for all textures.  <a href="#a60e62cb6b00f8ae9e9da077d0ecc08ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a8d44a97049862fc9c5eb64caf5cbbc2f">setSceneBlending</a> (const <a class="el" href="group__Materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the kind of blending every pass has with the existing contents of the scene.  <a href="#a8d44a97049862fc9c5eb64caf5cbbc2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#add4cd758dc843921da3a331bcc1bee1d">setSeparateSceneBlending</a> (const <a class="el" href="group__Materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbt, const <a class="el" href="group__Materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbta)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels.  <a href="#add4cd758dc843921da3a331bcc1bee1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a50815d7c51c153e2a6ab1b581507d28f">setSceneBlending</a> (const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows very fine control of blending every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the existing contents of the scene.  <a href="#a50815d7c51c153e2a6ab1b581507d28f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a5df9ffbf40cbce69799b3be95cf4b701">setSeparateSceneBlending</a> (const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor, const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactorAlpha, const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactorAlpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows very fine control of blending every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the existing contents of the scene, using individual factors both color and alpha channels.  <a href="#a5df9ffbf40cbce69799b3be95cf4b701"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ab72db7823cc9a8e872aed1ca6ae2cff8">setLodIndex</a> (unsigned short index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns a level-of-detail (LOD) index to this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#ab72db7823cc9a8e872aed1ca6ae2cff8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#af70e2e5fec4b833152ec435b4d105be7">getLodIndex</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the level-of-detail index assigned to this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#af70e2e5fec4b833152ec435b4d105be7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a43b6c4e9e48c4e56f96633b916ee90a3">setSchemeName</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;schemeName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the 'scheme name' for this technique.  <a href="#a43b6c4e9e48c4e56f96633b916ee90a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a2b3e4ec269e9f88a5a53a301ddb601a4">getSchemeName</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the scheme to which this technique is assigned.  <a href="#a2b3e4ec269e9f88a5a53a301ddb601a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#abab9570d1a0eb73194afa59c8e20de19">_getSchemeIndex</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for getting the scheme index.  <a href="#abab9570d1a0eb73194afa59c8e20de19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aa49639c4945e7d904bfcefe2d7ff3dd6">isDepthWriteEnabled</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is depth writing going to occur on this technique?  <a href="#aa49639c4945e7d904bfcefe2d7ff3dd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a483a1f2f5c7b197c2623850e4fdced1f">isDepthCheckEnabled</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is depth checking going to occur on this technique?  <a href="#a483a1f2f5c7b197c2623850e4fdced1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a8a55bcf42608e33443dcfc03b9a47269">hasColourWriteDisabled</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exists colour writing disabled pass on this technique?  <a href="#a8a55bcf42608e33443dcfc03b9a47269"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a365b0e6313b646d0ecc13c1c52a6d3ad">setName</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of the technique.  <a href="#a365b0e6313b646d0ecc13c1c52a6d3ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#af577087e6a66bd0a29a58d042b3a6d16">getName</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the technique.  <a href="#af577087e6a66bd0a29a58d042b3a6d16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ad2358b1ad69456e1ad0b73dff5522c95">applyTextureAliases</a> (const <a class="el" href="group__General.html#ga20898062bd79359acd1137276d9b0e37">AliasTextureNamePairList</a> &amp;aliasList, const bool apply=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies texture names to <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State with matching texture name aliases.  <a href="#ad2358b1ad69456e1ad0b73dff5522c95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#afe3b09baa8cd8566f994ad4ee5d125d1">addGPUVendorRule</a> (GPUVendor vendor, <a class="el" href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> includeOrExclude)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a GPU vendor.  <a href="#afe3b09baa8cd8566f994ad4ee5d125d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ac6a82a8dedd6ecc9228e392aec08bd52">addGPUVendorRule</a> (const <a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a> &amp;rule)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a GPU vendor.  <a href="#ac6a82a8dedd6ecc9228e392aec08bd52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aeaadeb93509d6fc3ca27686ca83e76be">removeGPUVendorRule</a> (GPUVendor vendor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a matching vendor rule.  <a href="#aeaadeb93509d6fc3ca27686ca83e76be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1ConstVectorIterator.html">GPUVendorRuleIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#abc1e584d7310c4d80cf09d6fa1dc0585">getGPUVendorRuleIterator</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the currently registered vendor rules.  <a href="#abc1e584d7310c4d80cf09d6fa1dc0585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ab6be978dbdbe321f7e8e9803aa29c2d1">addGPUDeviceNameRule</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;devicePattern, <a class="el" href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> includeOrExclude, bool caseSensitive=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g.  <a href="#ab6be978dbdbe321f7e8e9803aa29c2d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ad0b1efd013753818ae29fd15a27c9744">addGPUDeviceNameRule</a> (const <a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a> &amp;rule)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g.  <a href="#ad0b1efd013753818ae29fd15a27c9744"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a593e0e3c8e9d7a43155be8c6fdbfa8f7">removeGPUDeviceNameRule</a> (const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;devicePattern)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a matching device name rule.  <a href="#a593e0e3c8e9d7a43155be8c6fdbfa8f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1ConstVectorIterator.html">GPUDeviceNameRuleIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#addfd85590b126fb42c0cbffac10fff41">getGPUDeviceNameRuleIterator</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the currently registered device name rules.  <a href="#addfd85590b126fb42c0cbffac10fff41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a96db53bdf6b3f097fcb9a038df84abe9">getUserObjectBindings</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#a96db53bdf6b3f097fcb9a038df84abe9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aded444b9a20ee36d9a8a7a457d9b3e69">getUserObjectBindings</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#aded444b9a20ee36d9a8a7a457d9b3e69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a8dee9e7ef067309148721ed733264d23">IlluminationPassesState</a> { <a class="el" href="classOgre_1_1Technique.html#a8dee9e7ef067309148721ed733264d23a75b214ee6385d48d7ac8ffe63956ef9d">IPS_COMPILE_DISABLED</a> =  -1, 
<a class="el" href="classOgre_1_1Technique.html#a8dee9e7ef067309148721ed733264d23a6d7b35400e16649614a7b7d2ff935c93">IPS_NOT_COMPILED</a> =  0, 
<a class="el" href="classOgre_1_1Technique.html#a8dee9e7ef067309148721ed733264d23abbba3e91e244942ff28459e90885ede7">IPS_COMPILED</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt; <a class="el" href="classOgre_1_1Pass.html">Pass</a> * &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a2578716e1f4b4cf2a9d3102a48aaf235">Passes</a></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a2aab03fdccbf1973eb19ceecd264af30">clearIlluminationPasses</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for clearing illumination pass list.  <a href="#a2aab03fdccbf1973eb19ceecd264af30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a98175339d8f896cd76055316b03a6937">checkManuallyOrganisedIlluminationPasses</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method - check for manually assigned illumination passes.  <a href="#a98175339d8f896cd76055316b03a6937"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html#a2578716e1f4b4cf2a9d3102a48aaf235">Passes</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a45f4c97bd9168c67c4e7d5e68b2d0deb">mPasses</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of primary passes.  <a href="#a45f4c97bd9168c67c4e7d5e68b2d0deb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Materials.html#ga4c6928d029248ab4e1a4f999972baee8">IlluminationPassList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a6221e827be4159d329ae7909a542b10b">mIlluminationPasses</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of derived passes, categorised into IlluminationStage (ordered).  <a href="#a6221e827be4159d329ae7909a542b10b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Material.html">Material</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a19396048e38ac2ee8c49a1beeec22a1a">mParent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ab0140f0bcb0875742de251050440d546">mIsSupported</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html#a8dee9e7ef067309148721ed733264d23">IlluminationPassesState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a20375ceabd360a6b536a626da5033158">mIlluminationPassesCompilationPhase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a640ffe897c7889af3e6c6c9d322afcf7">mLodIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LOD level.  <a href="#a640ffe897c7889af3e6c6c9d322afcf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a0660deaa1aec81d2b440ab175d63514a">mSchemeIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheme index, derived from scheme name but the names are held on <a class="el" href="classOgre_1_1MaterialManager.html" title="Class for managing Material settings for Ogre.">MaterialManager</a>, for speed an index is used here.  <a href="#a0660deaa1aec81d2b440ab175d63514a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a386fbbee39283e296f9fb8bb3f4383f6">mName</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1MaterialPtr.html">MaterialPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a619d28fcc7d7763a6858f2e1a9499454">mShadowCasterMaterial</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When casting shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow casting material, or nor using fixed function casting, mShadowCasterMaterial let you customize per material shadow caster behavior.  <a href="#a619d28fcc7d7763a6858f2e1a9499454"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a7abd113d2ad69679463a9928b546d2ac">mShadowCasterMaterialName</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When casting shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow casting material, or nor using fixed function casting, mShadowCasterMaterial let you customize per material shadow caster behavior.There only material name is stored so that it can be loaded once all file parsed in a resource group.  <a href="#a7abd113d2ad69679463a9928b546d2ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1MaterialPtr.html">MaterialPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a4d1b3ffc258b9a2430326d0bb903dbb1">mShadowReceiverMaterial</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When receiving shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow receiving material, or nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material shadow caster behavior.  <a href="#a4d1b3ffc258b9a2430326d0bb903dbb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a6c4cb6c2977637223069c538986aa59e">mShadowReceiverMaterialName</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When receiving shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow receiving material, or nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material shadow caster behavior.  <a href="#a6c4cb6c2977637223069c538986aa59e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#aed349028e71fba8fc7c8a5ea71c1066e">mUserObjectBindings</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html#aa110f5f6056965bfb02099099fb46958">GPUVendorRuleList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a874f049c7a6b21f3b91e12ca5860330e">mGPUVendorRules</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html#a98091dbc9cb06b40138458537c36e3ed">GPUDeviceNameRuleList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a75739b100b635fbfd9760265239c34f3">mGPUDeviceNameRules</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class representing an approach to rendering this particular <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="namespaceOgre.html">Ogre</a> will attempt to use the best technique supported by the active hardware, unless you specifically request a lower detail technique (say for distant rendering). </dd></dl>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00053">53</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a63da4eb10f7272486a9806374b09bab6"></a><!-- doxytag: member="Ogre::Technique::GPUDeviceNameRuleIterator" ref="a63da4eb10f7272486a9806374b09bab6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstVectorIterator</a>&lt;<a class="el" href="classOgre_1_1Technique.html#a98091dbc9cb06b40138458537c36e3ed">GPUDeviceNameRuleList</a>&gt; <a class="el" href="classOgre_1_1ConstVectorIterator.html">Ogre::Technique::GPUDeviceNameRuleIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00692">692</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a98091dbc9cb06b40138458537c36e3ed"></a><!-- doxytag: member="Ogre::Technique::GPUDeviceNameRuleList" ref="a98091dbc9cb06b40138458537c36e3ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt;<a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a>&gt;::type <a class="el" href="classOgre_1_1Technique.html#a98091dbc9cb06b40138458537c36e3ed">Ogre::Technique::GPUDeviceNameRuleList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00143">143</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2497a0043902e9d2af0757d769da655c"></a><!-- doxytag: member="Ogre::Technique::GPUVendorRuleIterator" ref="a2497a0043902e9d2af0757d769da655c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstVectorIterator</a>&lt;<a class="el" href="classOgre_1_1Technique.html#aa110f5f6056965bfb02099099fb46958">GPUVendorRuleList</a>&gt; <a class="el" href="classOgre_1_1ConstVectorIterator.html">Ogre::Technique::GPUVendorRuleIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00651">651</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa110f5f6056965bfb02099099fb46958"></a><!-- doxytag: member="Ogre::Technique::GPUVendorRuleList" ref="aa110f5f6056965bfb02099099fb46958" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt;<a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a>&gt;::type <a class="el" href="classOgre_1_1Technique.html#aa110f5f6056965bfb02099099fb46958">Ogre::Technique::GPUVendorRuleList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00142">142</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a77a239a5901d2c67add2e7cea0bf3468"></a><!-- doxytag: member="Ogre::Technique::IlluminationPassIterator" ref="a77a239a5901d2c67add2e7cea0bf3468" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1VectorIterator.html">VectorIterator</a>&lt;<a class="el" href="group__Materials.html#ga4c6928d029248ab4e1a4f999972baee8">IlluminationPassList</a>&gt; <a class="el" href="classOgre_1_1VectorIterator.html">Ogre::Technique::IlluminationPassIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00201">201</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2578716e1f4b4cf2a9d3102a48aaf235"></a><!-- doxytag: member="Ogre::Technique::Passes" ref="a2578716e1f4b4cf2a9d3102a48aaf235" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt;<a class="el" href="classOgre_1_1Pass.html">Pass</a>*&gt;::type <a class="el" href="classOgre_1_1Technique.html#a2578716e1f4b4cf2a9d3102a48aaf235">Ogre::Technique::Passes</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00064">64</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b4640d3383f331657fd9ee05cb835c2"></a><!-- doxytag: member="Ogre::Technique::PassIterator" ref="a3b4640d3383f331657fd9ee05cb835c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1VectorIterator.html">VectorIterator</a>&lt;<a class="el" href="classOgre_1_1Technique.html#a2578716e1f4b4cf2a9d3102a48aaf235">Passes</a>&gt; <a class="el" href="classOgre_1_1VectorIterator.html">Ogre::Technique::PassIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00198">198</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a8dee9e7ef067309148721ed733264d23"></a><!-- doxytag: member="Ogre::Technique::IlluminationPassesState" ref="a8dee9e7ef067309148721ed733264d23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1Technique.html#a8dee9e7ef067309148721ed733264d23">Ogre::Technique::IlluminationPassesState</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8dee9e7ef067309148721ed733264d23a75b214ee6385d48d7ac8ffe63956ef9d"></a><!-- doxytag: member="IPS_COMPILE_DISABLED" ref="a8dee9e7ef067309148721ed733264d23a75b214ee6385d48d7ac8ffe63956ef9d" args="" -->IPS_COMPILE_DISABLED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8dee9e7ef067309148721ed733264d23a6d7b35400e16649614a7b7d2ff935c93"></a><!-- doxytag: member="IPS_NOT_COMPILED" ref="a8dee9e7ef067309148721ed733264d23a6d7b35400e16649614a7b7d2ff935c93" args="" -->IPS_NOT_COMPILED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8dee9e7ef067309148721ed733264d23abbba3e91e244942ff28459e90885ede7"></a><!-- doxytag: member="IPS_COMPILED" ref="a8dee9e7ef067309148721ed733264d23abbba3e91e244942ff28459e90885ede7" args="" -->IPS_COMPILED</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00057">57</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ade219e17b5e8d73d079d11f64a2a2d"></a><!-- doxytag: member="Ogre::Technique::IncludeOrExclude" ref="a1ade219e17b5e8d73d079d11f64a2a2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">Ogre::Technique::IncludeOrExclude</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directive used to manually control technique support based on the inclusion or exclusion of some factor. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1ade219e17b5e8d73d079d11f64a2a2dabd4cc2de655eff5194cda7ea50d00ee3"></a><!-- doxytag: member="INCLUDE" ref="a1ade219e17b5e8d73d079d11f64a2a2dabd4cc2de655eff5194cda7ea50d00ee3" args="" -->INCLUDE</em>&nbsp;</td><td>
<p>Inclusive - only support if present. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1ade219e17b5e8d73d079d11f64a2a2da043f697946b7a6d01bb858768e6646a3"></a><!-- doxytag: member="EXCLUDE" ref="a1ade219e17b5e8d73d079d11f64a2a2da043f697946b7a6d01bb858768e6646a3" args="" -->EXCLUDE</em>&nbsp;</td><td>
<p>Exclusive - do not support if present. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00114">114</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4bf5eef2cd88abdf3408234f2bb0899c"></a><!-- doxytag: member="Ogre::Technique::Technique" ref="a4bf5eef2cd88abdf3408234f2bb0899c" args="(Material *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::Technique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Material.html">Material</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a0e0fe6b1b297d9c8e81287d7c7a7b377"></a><!-- doxytag: member="Ogre::Technique::Technique" ref="a0e0fe6b1b297d9c8e81287d7c7a7b377" args="(Material *parent, const Technique &amp;oth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::Technique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Material.html">Material</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>oth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a3942999affa2e3a81d122ac58f181f11"></a><!-- doxytag: member="Ogre::Technique::~Technique" ref="a3942999affa2e3a81d122ac58f181f11" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::~Technique </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abec5e34e76944eb89ac0c6d370e3b1d5"></a><!-- doxytag: member="Ogre::Technique::_compile" ref="abec5e34e76944eb89ac0c6d370e3b1d5" args="(bool autoManageTextureUnits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::Technique::_compile </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoManageTextureUnits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal compilation method; see <a class="el" href="classOgre_1_1Material.html#a1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> information explaining problems with the compile. </dd></dl>

</div>
</div>
<a class="anchor" id="a8143f16e1759f3b5731389d59a66f309"></a><!-- doxytag: member="Ogre::Technique::_compileIlluminationPasses" ref="a8143f16e1759f3b5731389d59a66f309" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_compileIlluminationPasses </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method for splitting the passes into illumination passes. </p>

</div>
</div>
<a class="anchor" id="abab9570d1a0eb73194afa59c8e20de19"></a><!-- doxytag: member="Ogre::Technique::_getSchemeIndex" ref="abab9570d1a0eb73194afa59c8e20de19" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Technique::_getSchemeIndex </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method for getting the scheme index. </p>

</div>
</div>
<a class="anchor" id="a92b98b4f291fa76b02d2adeb822998af"></a><!-- doxytag: member="Ogre::Technique::_load" ref="a92b98b4f291fa76b02d2adeb822998af" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_load </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal load method, derived from call to <a class="el" href="classOgre_1_1Resource.html#a699d1c851f494a8d5d23d23b695ceb47" title="Loads the resource, if it is not already.">Material::load</a>. </p>

</div>
</div>
<a class="anchor" id="aa5ad18f720bba21676f3424ed7b2382d"></a><!-- doxytag: member="Ogre::Technique::_notifyNeedsRecompile" ref="aa5ad18f720bba21676f3424ed7b2382d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_notifyNeedsRecompile </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the technique that it needs recompilation. </p>

</div>
</div>
<a class="anchor" id="a5833abf80056c4a18b6eafb137b590bb"></a><!-- doxytag: member="Ogre::Technique::_prepare" ref="a5833abf80056c4a18b6eafb137b590bb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_prepare </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal prepare method, derived from call to <a class="el" href="classOgre_1_1Resource.html#a350b287fa3e83a389221274f68760008" title="Prepares the resource for load, if it is not already.">Material::prepare</a>. </p>

</div>
</div>
<a class="anchor" id="a73c19a7dd382f37226f307c3afc98794"></a><!-- doxytag: member="Ogre::Technique::_unload" ref="a73c19a7dd382f37226f307c3afc98794" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_unload </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal unload method, derived from call to <a class="el" href="classOgre_1_1Resource.html#aa31bef1bfaa87731622e56f11b548e27" title="Unloads the resource; this is not permanent, the resource can be reloaded later if...">Material::unload</a>. </p>

</div>
</div>
<a class="anchor" id="ad78f99fe8c81b1dffaf2d9bfc3cfabb4"></a><!-- doxytag: member="Ogre::Technique::_unprepare" ref="ad78f99fe8c81b1dffaf2d9bfc3cfabb4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_unprepare </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal unprepare method, derived from call to Material::unprepare. </p>

</div>
</div>
<a class="anchor" id="ad0b1efd013753818ae29fd15a27c9744"></a><!-- doxytag: member="Ogre::Technique::addGPUDeviceNameRule" ref="ad0b1efd013753818ae29fd15a27c9744" args="(const GPUDeviceNameRule &amp;rule)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUDeviceNameRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rule</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. </p>
<p>'*8800*'). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU device name pattern. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. The pattern you supply can include wildcard characters ('*') if you only want to match part of the device name. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same device pattern will be removed before adding this one. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6be978dbdbe321f7e8e9803aa29c2d1"></a><!-- doxytag: member="Ogre::Technique::addGPUDeviceNameRule" ref="ab6be978dbdbe321f7e8e9803aa29c2d1" args="(const String &amp;devicePattern, IncludeOrExclude includeOrExclude, bool caseSensitive=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUDeviceNameRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>devicePattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a>&nbsp;</td>
          <td class="paramname"> <em>includeOrExclude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>caseSensitive</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. </p>
<p>'*8800*'). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU device name pattern. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. The pattern you supply can include wildcard characters ('*') if you only want to match part of the device name. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same device pattern will be removed before adding this one. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devicePattern</em>&nbsp;</td><td>The GPU vendor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>includeOrExclude</em>&nbsp;</td><td>Whether this is an inclusive or exclusive rule </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>caseSensitive</em>&nbsp;</td><td>Whether the match is case sensitive or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6a82a8dedd6ecc9228e392aec08bd52"></a><!-- doxytag: member="Ogre::Technique::addGPUVendorRule" ref="ac6a82a8dedd6ecc9228e392aec08bd52" args="(const GPUVendorRule &amp;rule)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUVendorRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rule</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a rule which manually influences the support for this technique based on a GPU vendor. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU vendor. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same vendor will be removed before adding this one. </dd></dl>

</div>
</div>
<a class="anchor" id="afe3b09baa8cd8566f994ad4ee5d125d1"></a><!-- doxytag: member="Ogre::Technique::addGPUVendorRule" ref="afe3b09baa8cd8566f994ad4ee5d125d1" args="(GPUVendor vendor, IncludeOrExclude includeOrExclude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUVendorRule </td>
          <td>(</td>
          <td class="paramtype">GPUVendor&nbsp;</td>
          <td class="paramname"> <em>vendor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a>&nbsp;</td>
          <td class="paramname"> <em>includeOrExclude</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a rule which manually influences the support for this technique based on a GPU vendor. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU vendor. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same vendor will be removed before adding this one. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vendor</em>&nbsp;</td><td>The GPU vendor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>includeOrExclude</em>&nbsp;</td><td>Whether this is an inclusive or exclusive rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2358b1ad69456e1ad0b73dff5522c95"></a><!-- doxytag: member="Ogre::Technique::applyTextureAliases" ref="ad2358b1ad69456e1ad0b73dff5522c95" args="(const AliasTextureNamePairList &amp;aliasList, const bool apply=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::applyTextureAliases </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__General.html#ga20898062bd79359acd1137276d9b0e37">AliasTextureNamePairList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aliasList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>apply</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies texture names to <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State with matching texture name aliases. </p>
<p>All passes, and <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit States within the technique are checked. If matching texture aliases are found then true is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aliasList</em>&nbsp;</td><td>is a map container of texture alias, texture name pairs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>apply</em>&nbsp;</td><td>set true to apply the texture aliases else just test to see if texture alias matches are found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if matching texture aliases were found in the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa99b43fb531b833bc7e7ce939af2d069"></a><!-- doxytag: member="Ogre::Technique::checkGPURules" ref="aa99b43fb531b833bc7e7ce939af2d069" args="(StringUtil::StrStreamType &amp;errors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::checkGPURules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1StringUtil.html#a665d79932d54b48b83acff563de7a9e5">StringUtil::StrStreamType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>errors</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method for checking GPU vendor / device rules. </p>

</div>
</div>
<a class="anchor" id="a55699308ac7d558e4715356270204078"></a><!-- doxytag: member="Ogre::Technique::checkHardwareSupport" ref="a55699308ac7d558e4715356270204078" args="(bool autoManageTextureUnits, StringUtil::StrStreamType &amp;compileErrors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::checkHardwareSupport </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoManageTextureUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1StringUtil.html#a665d79932d54b48b83acff563de7a9e5">StringUtil::StrStreamType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>compileErrors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method for checking hardware support. </p>

</div>
</div>
<a class="anchor" id="a98175339d8f896cd76055316b03a6937"></a><!-- doxytag: member="Ogre::Technique::checkManuallyOrganisedIlluminationPasses" ref="a98175339d8f896cd76055316b03a6937" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::checkManuallyOrganisedIlluminationPasses </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method - check for manually assigned illumination passes. </p>

</div>
</div>
<a class="anchor" id="a2aab03fdccbf1973eb19ceecd264af30"></a><!-- doxytag: member="Ogre::Technique::clearIlluminationPasses" ref="a2aab03fdccbf1973eb19ceecd264af30" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::clearIlluminationPasses </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method for clearing illumination pass list. </p>

</div>
</div>
<a class="anchor" id="a51466b61bfe2dbcdb1afbf21b1dd3253"></a><!-- doxytag: member="Ogre::Technique::createPass" ref="a51466b61bfe2dbcdb1afbf21b1dd3253" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::Technique::createPass </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> for this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> is a single rendering pass, i.e. a single draw of the given material. Note that if you create a pass without a fragment program, during compilation of the material the pass may be split into multiple passes if the graphics card cannot handle the number of texture units requested. For passes with fragment programs, however, the number of passes you create will never be altered, so you have to make sure that you create an alternative fallback <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> for if a card does not have enough facilities for what you're asking for. </dd></dl>

</div>
</div>
<a class="anchor" id="addfd85590b126fb42c0cbffac10fff41"></a><!-- doxytag: member="Ogre::Technique::getGPUDeviceNameRuleIterator" ref="addfd85590b126fb42c0cbffac10fff41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ConstVectorIterator.html">GPUDeviceNameRuleIterator</a> Ogre::Technique::getGPUDeviceNameRuleIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an iterator over the currently registered device name rules. </p>

</div>
</div>
<a class="anchor" id="abc1e584d7310c4d80cf09d6fa1dc0585"></a><!-- doxytag: member="Ogre::Technique::getGPUVendorRuleIterator" ref="abc1e584d7310c4d80cf09d6fa1dc0585" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ConstVectorIterator.html">GPUVendorRuleIterator</a> Ogre::Technique::getGPUVendorRuleIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an iterator over the currently registered vendor rules. </p>

</div>
</div>
<a class="anchor" id="aa864634545c3b7d57888cb8118d4af0a"></a><!-- doxytag: member="Ogre::Technique::getIlluminationPassIterator" ref="aa864634545c3b7d57888cb8118d4af0a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1VectorIterator.html">IlluminationPassIterator</a> Ogre::Technique::getIlluminationPassIterator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an iterator over the illumination-stage categorised passes. </p>

</div>
</div>
<a class="anchor" id="af70e2e5fec4b833152ec435b4d105be7"></a><!-- doxytag: member="Ogre::Technique::getLodIndex" ref="af70e2e5fec4b833152ec435b4d105be7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Technique::getLodIndex </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the level-of-detail index assigned to this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00557">557</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="af577087e6a66bd0a29a58d042b3a6d16"></a><!-- doxytag: member="Ogre::Technique::getName" ref="af577087e6a66bd0a29a58d042b3a6d16" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Technique::getName </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the name of the technique. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00601">601</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7c787f22ac8d5efceebb65ae35ac6ef4"></a><!-- doxytag: member="Ogre::Technique::getNumPasses" ref="a7c787f22ac8d5efceebb65ae35ac6ef4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Technique::getNumPasses </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of passes. </p>

</div>
</div>
<a class="anchor" id="a603fb40984083fbdfa1bf570cc602563"></a><!-- doxytag: member="Ogre::Technique::getParent" ref="a603fb40984083fbdfa1bf570cc602563" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Material.html">Material</a>* Ogre::Technique::getParent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the parent <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00205">205</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a70cead1f1ccc258c493306fb4570b522"></a><!-- doxytag: member="Ogre::Technique::getPass" ref="a70cead1f1ccc258c493306fb4570b522" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::Technique::getPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> matching name. </p>
<p>Returns 0 if name match is not found. </p>

</div>
</div>
<a class="anchor" id="a3ce84da25bb6b5762af714adaf70874a"></a><!-- doxytag: member="Ogre::Technique::getPass" ref="a3ce84da25bb6b5762af714adaf70874a" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::Technique::getPass </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the given index. </p>

</div>
</div>
<a class="anchor" id="a84f0ff4e856f6965c7ae8dcab67e6cf2"></a><!-- doxytag: member="Ogre::Technique::getPassIterator" ref="a84f0ff4e856f6965c7ae8dcab67e6cf2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1VectorIterator.html">PassIterator</a> Ogre::Technique::getPassIterator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an iterator over the passes in this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>

</div>
</div>
<a class="anchor" id="aad5c43b5aa506b6304204f3874a251df"></a><!-- doxytag: member="Ogre::Technique::getResourceGroup" ref="aad5c43b5aa506b6304204f3874a251df" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Technique::getResourceGroup </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the resource group of the ultimate parent <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>. </p>

</div>
</div>
<a class="anchor" id="a2b3e4ec269e9f88a5a53a301ddb601a4"></a><!-- doxytag: member="Ogre::Technique::getSchemeName" ref="a2b3e4ec269e9f88a5a53a301ddb601a4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Technique::getSchemeName </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the scheme to which this technique is assigned. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Technique.html#a43b6c4e9e48c4e56f96633b916ee90a3" title="Set the &#39;scheme name&#39; for this technique.">Technique::setSchemeName</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4186641fe103b4ffcee48c708d1e8f42"></a><!-- doxytag: member="Ogre::Technique::getShadowCasterMaterial" ref="a4186641fe103b4ffcee48c708d1e8f42" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a> Ogre::Technique::getShadowCasterMaterial </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return this material specific shadow casting specific material </p>

</div>
</div>
<a class="anchor" id="ae40e12c1d7a1a3194bdf5ad68ba58fd0"></a><!-- doxytag: member="Ogre::Technique::getShadowReceiverMaterial" ref="ae40e12c1d7a1a3194bdf5ad68ba58fd0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a> Ogre::Technique::getShadowReceiverMaterial </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return this material specific shadow receiving specific material </p>

</div>
</div>
<a class="anchor" id="aded444b9a20ee36d9a8a7a457d9b3e69"></a><!-- doxytag: member="Ogre::Technique::getUserObjectBindings" ref="aded444b9a20ee36d9a8a7a457d9b3e69" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a>&amp; Ogre::Technique::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1UserObjectBindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a>. </dd></dl>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00706">706</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a96db53bdf6b3f097fcb9a038df84abe9"></a><!-- doxytag: member="Ogre::Technique::getUserObjectBindings" ref="a96db53bdf6b3f097fcb9a038df84abe9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a>&amp; Ogre::Technique::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1UserObjectBindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a>. </dd></dl>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00700">700</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a55bcf42608e33443dcfc03b9a47269"></a><!-- doxytag: member="Ogre::Technique::hasColourWriteDisabled" ref="a8a55bcf42608e33443dcfc03b9a47269" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::hasColourWriteDisabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exists colour writing disabled pass on this technique? </p>

</div>
</div>
<a class="anchor" id="a483a1f2f5c7b197c2623850e4fdced1f"></a><!-- doxytag: member="Ogre::Technique::isDepthCheckEnabled" ref="a483a1f2f5c7b197c2623850e4fdced1f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isDepthCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is depth checking going to occur on this technique? </p>

</div>
</div>
<a class="anchor" id="aa49639c4945e7d904bfcefe2d7ff3dd6"></a><!-- doxytag: member="Ogre::Technique::isDepthWriteEnabled" ref="aa49639c4945e7d904bfcefe2d7ff3dd6" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isDepthWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is depth writing going to occur on this technique? </p>

</div>
</div>
<a class="anchor" id="aac374abdbf430a519dafb578f36239ff"></a><!-- doxytag: member="Ogre::Technique::isLoaded" ref="aac374abdbf430a519dafb578f36239ff" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isLoaded </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f64b7cc4743ee7cc5d6782ba687d841"></a><!-- doxytag: member="Ogre::Technique::isSupported" ref="a7f64b7cc4743ee7cc5d6782ba687d841" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isSupported </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates if this technique is supported by the current graphics card. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This will only be correct after the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has been compiled, which is usually done from <a class="el" href="classOgre_1_1Material.html#a1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad22ecac74653f9d1a4c955cf865f41d4"></a><!-- doxytag: member="Ogre::Technique::isTransparent" ref="ad22ecac74653f9d1a4c955cf865f41d4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isTransparent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> involves transparency. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This basically boils down to whether the first pass has a scene blending factor. Even if the other passes do not, the base colour, including parts of the original scene, may be used for blending, therefore we have to treat the whole <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> as transparent. </dd></dl>

</div>
</div>
<a class="anchor" id="a7411b79f49c7136a55bd17eef1cc53ce"></a><!-- doxytag: member="Ogre::Technique::isTransparentSortingEnabled" ref="a7411b79f49c7136a55bd17eef1cc53ce" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isTransparentSortingEnabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting enabled. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This basically boils down to whether the first pass has transparent sorting enabled or not </dd></dl>

</div>
</div>
<a class="anchor" id="a5ec64a0826b7dfac29aa945e6cebfcde"></a><!-- doxytag: member="Ogre::Technique::isTransparentSortingForced" ref="a5ec64a0826b7dfac29aa945e6cebfcde" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isTransparentSortingForced </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting forced. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This basically boils down to whether the first pass has transparent sorting forced or not </dd></dl>

</div>
</div>
<a class="anchor" id="a6fe998209ba33ea38fdcef68743d678c"></a><!-- doxytag: member="Ogre::Technique::movePass" ref="a6fe998209ba33ea38fdcef68743d678c" args="(const unsigned short sourceIndex, const unsigned short destinationIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::movePass </td>
          <td>(</td>
          <td class="paramtype">const unsigned short&nbsp;</td>
          <td class="paramname"> <em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&nbsp;</td>
          <td class="paramname"> <em>destinationIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move a pass from source index to destination index. </p>
<p>If successful then returns true. </p>

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a><!-- doxytag: member="Ogre::Technique::operator delete" ref="acb46d4b0a597156d9ba5abc39d127792" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00107">107</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a><!-- doxytag: member="Ogre::Technique::operator delete" ref="a1c727e879a260c37b00ce5505fe8e144" args="(void *ptr, void *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00101">101</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a><!-- doxytag: member="Ogre::Technique::operator delete" ref="a8357fe4fb4849772b94baa4bf47c7ded" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00095">95</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a><!-- doxytag: member="Ogre::Technique::operator delete[]" ref="a595ea4c05da8aa987d3800e65d23355d" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00118">118</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a><!-- doxytag: member="Ogre::Technique::operator delete[]" ref="a93e6a86dde5483c053ca0f2a85bbfd6c" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00112">112</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a><!-- doxytag: member="Ogre::Technique::operator new" ref="ab78a921e54419be677839cdf15d1f0b8" args="(size_t sz, void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>placement operator new </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00078">78</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a><!-- doxytag: member="Ogre::Technique::operator new" ref="ac4bdf968b7b9af8a5239a27da73d5711" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00072">72</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a><!-- doxytag: member="Ogre::Technique::operator new" ref="a421b197ca3a38da17e2eb1531a645fa2" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00067">67</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a><!-- doxytag: member="Ogre::Technique::operator new[]" ref="afa2943846ba6a2b5824a12857139cf5e" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00090">90</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a><!-- doxytag: member="Ogre::Technique::operator new[]" ref="a4be37baef81876985aa1071ad5acc6dd" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>array operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00085">85</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac251efbed20452a6efb1361ea5d27496"></a><!-- doxytag: member="Ogre::Technique::operator=" ref="ac251efbed20452a6efb1361ea5d27496" args="(const Technique &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html">Technique</a>&amp; Ogre::Technique::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded operator to copy on <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to another. </p>

</div>
</div>
<a class="anchor" id="a1eaae1583cf2e6e310ae911d34da00be"></a><!-- doxytag: member="Ogre::Technique::removeAllPasses" ref="a1eaae1583cf2e6e310ae911d34da00be" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeAllPasses </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all Passes from this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>

</div>
</div>
<a class="anchor" id="a593e0e3c8e9d7a43155be8c6fdbfa8f7"></a><!-- doxytag: member="Ogre::Technique::removeGPUDeviceNameRule" ref="a593e0e3c8e9d7a43155be8c6fdbfa8f7" args="(const String &amp;devicePattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeGPUDeviceNameRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>devicePattern</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a matching device name rule. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Technique.html#ab6be978dbdbe321f7e8e9803aa29c2d1" title="Add a rule which manually influences the support for this technique based on a pattern...">addGPUDeviceNameRule</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeaadeb93509d6fc3ca27686ca83e76be"></a><!-- doxytag: member="Ogre::Technique::removeGPUVendorRule" ref="aeaadeb93509d6fc3ca27686ca83e76be" args="(GPUVendor vendor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeGPUVendorRule </td>
          <td>(</td>
          <td class="paramtype">GPUVendor&nbsp;</td>
          <td class="paramname"> <em>vendor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a matching vendor rule. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Technique.html#afe3b09baa8cd8566f994ad4ee5d125d1" title="Add a rule which manually influences the support for this technique based on a GPU...">addGPUVendorRule</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6cff3e7cbf0b677433ca0a0da04c6aa"></a><!-- doxytag: member="Ogre::Technique::removePass" ref="af6cff3e7cbf0b677433ca0a0da04c6aa" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removePass </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the given index. </p>

</div>
</div>
<a class="anchor" id="ac5d459624ede01672c78846825cc0f96"></a><!-- doxytag: member="Ogre::Technique::setAmbient" ref="ac5d459624ede01672c78846825cc0f96" args="(const ColourValue &amp;ambient)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setAmbient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ambient</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the ambient colour reflectance properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a606695927fbf85ee64c361abf66ac10e" title="Sets the ambient colour reflectance properties of this pass.">Pass::setAmbient</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a28bab7548009bc18723bc0dc20a44f6a"></a><!-- doxytag: member="Ogre::Technique::setAmbient" ref="a28bab7548009bc18723bc0dc20a44f6a" args="(Real red, Real green, Real blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setAmbient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the ambient colour reflectance properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a606695927fbf85ee64c361abf66ac10e" title="Sets the ambient colour reflectance properties of this pass.">Pass::setAmbient</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a155d2bb172e767eab0880667b8669057"></a><!-- doxytag: member="Ogre::Technique::setColourWriteEnabled" ref="a155d2bb172e767eab0880667b8669057" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setColourWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether or not colour buffer writing is enabled for each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a3bbe37daba7e3be4349177374d4e40ee" title="Sets whether or not colour buffer writing is enabled for this Pass.">Pass::setColourWriteEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3ab7639e71d6118834a9164a7c1c8f9"></a><!-- doxytag: member="Ogre::Technique::setCullingMode" ref="ae3ab7639e71d6118834a9164a7c1c8f9" args="(CullingMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setCullingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__General.html#gac173244ed7d950d0acd726e4f323ecdb">CullingMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the culling mode for each pass based on the 'vertex winding'. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a8942abf3ede0f3cb43584c85c4071734" title="Sets the culling mode for this pass based on the &#39;vertex winding&#39;.">Pass::setCullingMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a58b4e86384ca3e7a9f03c3fb2a5b3f0d"></a><!-- doxytag: member="Ogre::Technique::setDepthBias" ref="a58b4e86384ca3e7a9f03c3fb2a5b3f0d" args="(float constantBias, float slopeScaleBias)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>constantBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>slopeScaleBias</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the depth bias to be used for each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#aa35a3242a45176f8605bd8c866198b67" title="Sets the depth bias to be used for this material.">Pass::setDepthBias</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ccefe2b6bb5b6e66e2dcb081f92847f"></a><!-- doxytag: member="Ogre::Technique::setDepthCheckEnabled" ref="a8ccefe2b6bb5b6e66e2dcb081f92847f" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether or not each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> renders with depth-buffer checking on or not. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not.">Pass::setDepthCheckEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f8f52bd7bc067a8f6dac99757063a06"></a><!-- doxytag: member="Ogre::Technique::setDepthFunction" ref="a1f8f52bd7bc067a8f6dac99757063a06" args="(CompareFunction func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__General.html#ga0212b4eb264f207d84c1df9425208c7a">CompareFunction</a>&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the function used to compare depth values when depth checking is on. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#aef6c591b069aa6f7c65afc1419d47de6" title="Sets the function used to compare depth values when depth checking is on.">Pass::setDepthFunction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a17ab42d4b777c0782a2d0170ae5a0970"></a><!-- doxytag: member="Ogre::Technique::setDepthWriteEnabled" ref="a17ab42d4b777c0782a2d0170ae5a0970" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether or not each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> renders with depth-buffer writing on or not. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#aad3e6c7c7b59e2c303c348b4850b1a3a" title="Sets whether or not this pass renders with depth-buffer writing on or not.">Pass::setDepthWriteEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af5e13d58c70bbeeb1708e1479185a959"></a><!-- doxytag: member="Ogre::Technique::setDiffuse" ref="af5e13d58c70bbeeb1708e1479185a959" args="(const ColourValue &amp;diffuse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>diffuse</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the diffuse colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#ae371bb189752872dfa2e02694f6841f1" title="Sets the diffuse colour reflectance properties of this pass.">Pass::setDiffuse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a177ced7bb28cba1562a6d036a1b692f9"></a><!-- doxytag: member="Ogre::Technique::setDiffuse" ref="a177ced7bb28cba1562a6d036a1b692f9" args="(Real red, Real green, Real blue, Real alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDiffuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the diffuse colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#ae371bb189752872dfa2e02694f6841f1" title="Sets the diffuse colour reflectance properties of this pass.">Pass::setDiffuse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a42c07e62db4e2cbeb75f8253b30e5c3b"></a><!-- doxytag: member="Ogre::Technique::setFog" ref="a42c07e62db4e2cbeb75f8253b30e5c3b" args="(bool overrideScene, FogMode mode=FOG_NONE, const ColourValue &amp;colour=ColourValue::White, Real expDensity=0.001, Real linearStart=0.0, Real linearEnd=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setFog </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>overrideScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__General.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FOG_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em> = <code><a class="el" href="classOgre_1_1ColourValue.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>expDensity</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linearStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linearEnd</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the fogging mode applied to each pass. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a32b0cabffa642b0f3743ac5d82392a1d" title="Sets the fogging mode applied to this pass.">Pass::setFog</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6f31b910ad3b0a22219210290622482"></a><!-- doxytag: member="Ogre::Technique::setLightingEnabled" ref="ab6f31b910ad3b0a22219210290622482" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setLightingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether or not dynamic lighting is enabled for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Pass::setLightingEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab72db7823cc9a8e872aed1ca6ae2cff8"></a><!-- doxytag: member="Ogre::Technique::setLodIndex" ref="ab72db7823cc9a8e872aed1ca6ae2cff8" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setLodIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns a level-of-detail (LOD) index to this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>As noted previously, as well as providing fallback support for various graphics cards, multiple <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> objects can also be used to implement material LOD, where the detail of the material diminishes with distance to save rendering power. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>By default, all Techniques have a LOD index of 0, which means they are the highest level of detail. Increasing LOD indexes are lower levels of detail. You can assign more than one <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to the same LOD index, meaning that the best <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> that is supported at that LOD index is used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>You should not leave gaps in the LOD sequence; <a class="el" href="namespaceOgre.html">Ogre</a> will allow you to do this and will continue to function as if the LODs were sequential, but it will confuse matters. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d9340f9b31f6189e28d62ab00937ab0"></a><!-- doxytag: member="Ogre::Technique::setManualCullingMode" ref="a9d9340f9b31f6189e28d62ab00937ab0" args="(ManualCullingMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setManualCullingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__General.html#ga07ec94cf178172a6778223e6f70f23fc">ManualCullingMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the manual culling mode, performed by CPU rather than hardware. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a3b528827b54f17b72bb204321640a6f7" title="Sets the manual culling mode, performed by CPU rather than hardware.">Pass::setManualCullingMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a365b0e6313b646d0ecc13c1c52a6d3ad"></a><!-- doxytag: member="Ogre::Technique::setName" ref="a365b0e6313b646d0ecc13c1c52a6d3ad" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the name of the technique. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The use of technique name is optional. Its useful in material scripts where a material could inherit from another material and only want to modify a particular technique. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b7d1d264b34c50b7606c646415a50e8"></a><!-- doxytag: member="Ogre::Technique::setPointSize" ref="a1b7d1d264b34c50b7606c646415a50e8" args="(Real ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setPointSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>ps</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the point size properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a2b0cfe1d55b1c03e59c4e3f546d2ec78" title="Sets the point size of this pass.">Pass::setPointSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a50815d7c51c153e2a6ab1b581507d28f"></a><!-- doxytag: member="Ogre::Technique::setSceneBlending" ref="a50815d7c51c153e2a6ab1b581507d28f" args="(const SceneBlendFactor sourceFactor, const SceneBlendFactor destFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows very fine control of blending every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the existing contents of the scene. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#ae21d6f29c89eeff54ab6de5562818c02" title="Sets the kind of blending this pass has with the existing contents of the scene.">Pass::setSceneBlending</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d44a97049862fc9c5eb64caf5cbbc2f"></a><!-- doxytag: member="Ogre::Technique::setSceneBlending" ref="a8d44a97049862fc9c5eb64caf5cbbc2f" args="(const SceneBlendType sbt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&nbsp;</td>
          <td class="paramname"> <em>sbt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the kind of blending every pass has with the existing contents of the scene. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#ae21d6f29c89eeff54ab6de5562818c02" title="Sets the kind of blending this pass has with the existing contents of the scene.">Pass::setSceneBlending</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43b6c4e9e48c4e56f96633b916ee90a3"></a><!-- doxytag: member="Ogre::Technique::setSchemeName" ref="a43b6c4e9e48c4e56f96633b916ee90a3" args="(const String &amp;schemeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSchemeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>schemeName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the 'scheme name' for this technique. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> schemes are used to control top-level switching from one set of techniques to another. For example, you might use this to define 'high', 'medium' and 'low' complexity levels on materials to allow a user to pick a performance / quality ratio. Another possibility is that you have a fully HDR-enabled pipeline for top machines, rendering all objects using unclamped shaders, and a simpler pipeline for others; this can be implemented using schemes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Every technique belongs to a scheme - if you don't specify one, the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> belongs to the scheme called 'Default', which is also the scheme used to render by default. The active scheme is set one of two ways - either by calling <a class="el" href="classOgre_1_1Viewport.html#a8e8577fd81c45b05de880106f364a281" title="Set the material scheme which the viewport should use.">Viewport::setMaterialScheme</a>, or by manually calling <a class="el" href="classOgre_1_1MaterialManager.html#a95decc3900f547bb68b74ba28d3013e0" title="Sets the name of the active material scheme.">MaterialManager::setActiveScheme</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e5d7120bf501c5796bb461ec16ca22d"></a><!-- doxytag: member="Ogre::Technique::setSelfIllumination" ref="a9e5d7120bf501c5796bb461ec16ca22d" args="(const ColourValue &amp;selfIllum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSelfIllumination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>selfIllum</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the amount of self-illumination of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a511812da930186cb3fe15e286bc2d244" title="Sets the amount of self-illumination an object has.">Pass::setSelfIllumination</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa987bf7df6c05a27a25ee334527498a0"></a><!-- doxytag: member="Ogre::Technique::setSelfIllumination" ref="aa987bf7df6c05a27a25ee334527498a0" args="(Real red, Real green, Real blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSelfIllumination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the amount of self-illumination of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a511812da930186cb3fe15e286bc2d244" title="Sets the amount of self-illumination an object has.">Pass::setSelfIllumination</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5df9ffbf40cbce69799b3be95cf4b701"></a><!-- doxytag: member="Ogre::Technique::setSeparateSceneBlending" ref="a5df9ffbf40cbce69799b3be95cf4b701" args="(const SceneBlendFactor sourceFactor, const SceneBlendFactor destFactor, const SceneBlendFactor sourceFactorAlpha, const SceneBlendFactor destFactorAlpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSeparateSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactorAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactorAlpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows very fine control of blending every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the existing contents of the scene, using individual factors both color and alpha channels. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#aefbd80d762d78838df626482df1ac81b" title="Sets the kind of blending this pass has with the existing contents of the scene,...">Pass::setSeparateSceneBlending</a> </dd></dl>

</div>
</div>
<a class="anchor" id="add4cd758dc843921da3a331bcc1bee1d"></a><!-- doxytag: member="Ogre::Technique::setSeparateSceneBlending" ref="add4cd758dc843921da3a331bcc1bee1d" args="(const SceneBlendType sbt, const SceneBlendType sbta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSeparateSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&nbsp;</td>
          <td class="paramname"> <em>sbt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&nbsp;</td>
          <td class="paramname"> <em>sbta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#aefbd80d762d78838df626482df1ac81b" title="Sets the kind of blending this pass has with the existing contents of the scene,...">Pass::setSeparateSceneBlending</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c3bb63365c701842d4539e32cc1480e"></a><!-- doxytag: member="Ogre::Technique::setShadingMode" ref="a4c3bb63365c701842d4539e32cc1480e" args="(ShadeOptions mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__General.html#ga7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the type of light shading required. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#ade6c00297cd5d46bb365d981cd1764a6" title="Sets the type of light shading required.">Pass::setShadingMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7913e8419619f0b074e67a638d54eb0f"></a><!-- doxytag: member="Ogre::Technique::setShadowCasterMaterial" ref="a7913e8419619f0b074e67a638d54eb0f" args="(const Ogre::String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowCasterMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set this material specific shadow casting specific material </p>

</div>
</div>
<a class="anchor" id="ac0e017f3810451861191fedfe1d51a30"></a><!-- doxytag: member="Ogre::Technique::setShadowCasterMaterial" ref="ac0e017f3810451861191fedfe1d51a30" args="(Ogre::MaterialPtr val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowCasterMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set this material specific shadow casting specific material </p>

</div>
</div>
<a class="anchor" id="a03a7f4c6fa69c36b2b92a79917c34ace"></a><!-- doxytag: member="Ogre::Technique::setShadowReceiverMaterial" ref="a03a7f4c6fa69c36b2b92a79917c34ace" args="(const Ogre::String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowReceiverMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set this material specific shadow receiving specific material </p>

</div>
</div>
<a class="anchor" id="a14cb59e4b8d1073f5379378ccf43f103"></a><!-- doxytag: member="Ogre::Technique::setShadowReceiverMaterial" ref="a14cb59e4b8d1073f5379378ccf43f103" args="(Ogre::MaterialPtr val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowReceiverMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set this material specific shadow receiving specific material </p>

</div>
</div>
<a class="anchor" id="aed27a55db91366ee2f95a608f946bc86"></a><!-- doxytag: member="Ogre::Technique::setShininess" ref="aed27a55db91366ee2f95a608f946bc86" args="(Real val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShininess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the shininess properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a8202cf155d20602fd9c0ec53273a442f" title="Sets the shininess of the pass, affecting the size of specular highlights.">Pass::setShininess</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0add9d092f47eb2b654d936a66902d00"></a><!-- doxytag: member="Ogre::Technique::setSpecular" ref="a0add9d092f47eb2b654d936a66902d00" args="(const ColourValue &amp;specular)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSpecular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>specular</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the specular colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a8c079dd718b5839e1be10ee077a620b7" title="Sets the specular colour reflectance properties of this pass.">Pass::setSpecular</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f58112618978a38cb9396936a54586a"></a><!-- doxytag: member="Ogre::Technique::setSpecular" ref="a7f58112618978a38cb9396936a54586a" args="(Real red, Real green, Real blue, Real alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSpecular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the specular colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a8c079dd718b5839e1be10ee077a620b7" title="Sets the specular colour reflectance properties of this pass.">Pass::setSpecular</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a60e62cb6b00f8ae9e9da077d0ecc08ec"></a><!-- doxytag: member="Ogre::Technique::setTextureAnisotropy" ref="a60e62cb6b00f8ae9e9da077d0ecc08ec" args="(unsigned int maxAniso)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setTextureAnisotropy </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>maxAniso</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the anisotropy level to be used for all textures. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property has been moved to the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> class, which is accessible via the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> and <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>, <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> and <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> instances and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1TextureUnitState.html#abb2bc03bc72f2098e37c4240f637c5e5" title="Sets the anisotropy level to be used for this texture level.">TextureUnitState::setTextureAnisotropy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a67d7464ef321b859c33c3c1e9334c5f2"></a><!-- doxytag: member="Ogre::Technique::setTextureFiltering" ref="a67d7464ef321b859c33c3c1e9334c5f2" args="(TextureFilterOptions filterType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setTextureFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__General.html#ga21a0186392e9c9ce16d29c5568a773c5">TextureFilterOptions</a>&nbsp;</td>
          <td class="paramname"> <em>filterType</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set texture filtering for every texture unit in every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> class For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> and <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> instances and set the property there. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1TextureUnitState.html#a30757c168b734902d03720e3f36c27d4" title="Set the texture filtering for this unit, using the simplified interface.">TextureUnitState::setTextureFiltering</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a75739b100b635fbfd9760265239c34f3"></a><!-- doxytag: member="Ogre::Technique::mGPUDeviceNameRules" ref="a75739b100b635fbfd9760265239c34f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html#a98091dbc9cb06b40138458537c36e3ed">GPUDeviceNameRuleList</a> <a class="el" href="classOgre_1_1Technique.html#a75739b100b635fbfd9760265239c34f3">Ogre::Technique::mGPUDeviceNameRules</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00146">146</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a874f049c7a6b21f3b91e12ca5860330e"></a><!-- doxytag: member="Ogre::Technique::mGPUVendorRules" ref="a874f049c7a6b21f3b91e12ca5860330e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html#aa110f5f6056965bfb02099099fb46958">GPUVendorRuleList</a> <a class="el" href="classOgre_1_1Technique.html#a874f049c7a6b21f3b91e12ca5860330e">Ogre::Technique::mGPUVendorRules</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00145">145</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6221e827be4159d329ae7909a542b10b"></a><!-- doxytag: member="Ogre::Technique::mIlluminationPasses" ref="a6221e827be4159d329ae7909a542b10b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Materials.html#ga4c6928d029248ab4e1a4f999972baee8">IlluminationPassList</a> <a class="el" href="classOgre_1_1Technique.html#a6221e827be4159d329ae7909a542b10b">Ogre::Technique::mIlluminationPasses</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of derived passes, categorised into IlluminationStage (ordered). </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00068">68</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a20375ceabd360a6b536a626da5033158"></a><!-- doxytag: member="Ogre::Technique::mIlluminationPassesCompilationPhase" ref="a20375ceabd360a6b536a626da5033158" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html#a8dee9e7ef067309148721ed733264d23">IlluminationPassesState</a> <a class="el" href="classOgre_1_1Technique.html#a20375ceabd360a6b536a626da5033158">Ogre::Technique::mIlluminationPassesCompilationPhase</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00071">71</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab0140f0bcb0875742de251050440d546"></a><!-- doxytag: member="Ogre::Technique::mIsSupported" ref="ab0140f0bcb0875742de251050440d546" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Technique.html#ab0140f0bcb0875742de251050440d546">Ogre::Technique::mIsSupported</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00070">70</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a640ffe897c7889af3e6c6c9d322afcf7"></a><!-- doxytag: member="Ogre::Technique::mLodIndex" ref="a640ffe897c7889af3e6c6c9d322afcf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short <a class="el" href="classOgre_1_1Technique.html#a640ffe897c7889af3e6c6c9d322afcf7">Ogre::Technique::mLodIndex</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LOD level. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00073">73</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a386fbbee39283e296f9fb8bb3f4383f6"></a><!-- doxytag: member="Ogre::Technique::mName" ref="a386fbbee39283e296f9fb8bb3f4383f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1Technique.html#a386fbbee39283e296f9fb8bb3f4383f6">Ogre::Technique::mName</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00078">78</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19396048e38ac2ee8c49a1beeec22a1a"></a><!-- doxytag: member="Ogre::Technique::mParent" ref="a19396048e38ac2ee8c49a1beeec22a1a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Material.html">Material</a>* <a class="el" href="classOgre_1_1Technique.html#a19396048e38ac2ee8c49a1beeec22a1a">Ogre::Technique::mParent</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00069">69</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a45f4c97bd9168c67c4e7d5e68b2d0deb"></a><!-- doxytag: member="Ogre::Technique::mPasses" ref="a45f4c97bd9168c67c4e7d5e68b2d0deb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html#a2578716e1f4b4cf2a9d3102a48aaf235">Passes</a> <a class="el" href="classOgre_1_1Technique.html#a45f4c97bd9168c67c4e7d5e68b2d0deb">Ogre::Technique::mPasses</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of primary passes. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00066">66</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0660deaa1aec81d2b440ab175d63514a"></a><!-- doxytag: member="Ogre::Technique::mSchemeIndex" ref="a0660deaa1aec81d2b440ab175d63514a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short <a class="el" href="classOgre_1_1Technique.html#a0660deaa1aec81d2b440ab175d63514a">Ogre::Technique::mSchemeIndex</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scheme index, derived from scheme name but the names are held on <a class="el" href="classOgre_1_1MaterialManager.html" title="Class for managing Material settings for Ogre.">MaterialManager</a>, for speed an index is used here. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00077">77</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a619d28fcc7d7763a6858f2e1a9499454"></a><!-- doxytag: member="Ogre::Technique::mShadowCasterMaterial" ref="a619d28fcc7d7763a6858f2e1a9499454" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MaterialPtr.html">MaterialPtr</a> <a class="el" href="classOgre_1_1Technique.html#a619d28fcc7d7763a6858f2e1a9499454">Ogre::Technique::mShadowCasterMaterial</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When casting shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow casting material, or nor using fixed function casting, mShadowCasterMaterial let you customize per material shadow caster behavior. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00090">90</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7abd113d2ad69679463a9928b546d2ac"></a><!-- doxytag: member="Ogre::Technique::mShadowCasterMaterialName" ref="a7abd113d2ad69679463a9928b546d2ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1Technique.html#a7abd113d2ad69679463a9928b546d2ac">Ogre::Technique::mShadowCasterMaterialName</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When casting shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow casting material, or nor using fixed function casting, mShadowCasterMaterial let you customize per material shadow caster behavior.There only material name is stored so that it can be loaded once all file parsed in a resource group. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00095">95</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d1b3ffc258b9a2430326d0bb903dbb1"></a><!-- doxytag: member="Ogre::Technique::mShadowReceiverMaterial" ref="a4d1b3ffc258b9a2430326d0bb903dbb1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MaterialPtr.html">MaterialPtr</a> <a class="el" href="classOgre_1_1Technique.html#a4d1b3ffc258b9a2430326d0bb903dbb1">Ogre::Technique::mShadowReceiverMaterial</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When receiving shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow receiving material, or nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material shadow caster behavior. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00100">100</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6c4cb6c2977637223069c538986aa59e"></a><!-- doxytag: member="Ogre::Technique::mShadowReceiverMaterialName" ref="a6c4cb6c2977637223069c538986aa59e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1Technique.html#a6c4cb6c2977637223069c538986aa59e">Ogre::Technique::mShadowReceiverMaterialName</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When receiving shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow receiving material, or nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material shadow caster behavior. </p>
<p>There only material name is stored so that it can be loaded once all file parsed in a resource group. </p>

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00105">105</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<a class="anchor" id="aed349028e71fba8fc7c8a5ea71c1066e"></a><!-- doxytag: member="Ogre::Technique::mUserObjectBindings" ref="aed349028e71fba8fc7c8a5ea71c1066e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1UserObjectBindings.html">UserObjectBindings</a> <a class="el" href="classOgre_1_1Technique.html#aed349028e71fba8fc7c8a5ea71c1066e">Ogre::Technique::mUserObjectBindings</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreTechnique_8h_source.html#l00108">108</a> of file <a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreTechnique_8h_source.html">OgreTechnique.h</a></li>
</ul>
</div>
<hr>
<p>
Copyright &copy; 2008 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Wed Nov 3 20:34:08 2010
</p>
</body>
</html>
